[
  {
    "objectID": "homework.html",
    "href": "homework.html",
    "title": "",
    "section": "",
    "text": "Linear algebra basics\n\n[5 points] Sensitivity Analysis in Linear Systems Consider a nonsingular matrix A \\in \\mathbb{R}^{n \\times n} and a vector b \\in \\mathbb{R}^n. Suppose that due to measurement or computational errors, the vector b is perturbed to \\tilde{b} = b + \\delta b.\n\nDerive an upper bound for the relative error in the solution x of the system Ax = b in terms of the condition number \\kappa(A) and the relative error in b.\n\nProvide a concrete example using a 2 \\times 2 matrix where \\kappa(A) is large (say, \\geq 100500).\n\n[5 points] Effect of Diagonal Scaling on Rank Let A \\in \\mathbb{R}^{n \\times n} be a matrix with rank r. Suppose D \\in \\mathbb{R}^{n \\times n} is a diagonal matrix. Determine the rank of the product DA. Explain your reasoning.\n[8 points] Unexpected SVD Compute the Singular Value Decomposition (SVD) of the following matrices:\n\nA_1 = \\begin{bmatrix} 2 \\\\ 2 \\\\ 8 \\end{bmatrix}\nA_2 = \\begin{bmatrix} 0 & x \\\\ x & 0 \\\\ 0 & 0 \\end{bmatrix}, where x is the sum of your birthdate numbers (day + month).\n\n[10 points] Effect of normalization on rank Assume we have a set of data points x^{(i)}\\in\\mathbb{R}^{n},\\,i=1,\\dots,m, and decide to represent this data as a matrix \nX =\n\\begin{pmatrix}\n  | & & | \\\\\n  x^{(1)} & \\dots & x^{(m)} \\\\\n  | & & | \\\\\n\\end{pmatrix} \\in \\mathbb{R}^{n \\times m}.\n\nWe suppose that \\text{rank}\\,X = r.\nIn the problem below, we ask you to find the rank of some matrix M related to X. In particular, you need to find relation between \\text{rank}\\,X = r and \\text{rank}\\,M, e.g., that the rank of M is always larger/smaller than the rank of X or that \\text{rank}\\,M = \\text{rank}\\,X \\big / 35. Please support your answer with legitimate arguments and make the answer as accurate as possible.\nNote that border cases are possible depending on the structure of the matrix X. Make sure to cover them in your answer correctly.\nIn applied statistics and machine learning, data is often normalized. One particularly popular strategy is to subtract the estimated mean \\mu and divide by the square root of the estimated variance \\sigma^2. i.e. \nx \\rightarrow (x - \\mu) \\big / \\sigma.\n After the normalization, we get a new matrix \n\\begin{split}\nY &:=\n\\begin{pmatrix}\n  | & & | \\\\\n  y^{(1)} & \\dots & y^{(m)} \\\\\n  | & & | \\\\\n\\end{pmatrix},\\\\\ny^{(i)} &:= \\frac{x^{(i)} - \\frac{1}{m}\\sum_{j=1}^{m} x^{(j)}}{\\sigma}.\n\\end{split}\n What is the rank of Y if \\text{rank} \\; X = r? Here \\sigma is a vector and the division is element-wise. The reason for this is that different features might have different scales. Specifically: \n\\sigma_i = \\sqrt{\\frac{1}{m}\\sum_{j=1}^{m} \\left(x_i^{(j)}\\right)^2 - \\left(\\frac{1}{m}\\sum_{j=1}^{m} x_i^{(j)}\\right)^2}.\n\n[20 points] Image Compression with Truncated SVD Explore image compression using Truncated Singular Value Decomposition (SVD). Understand how varying the number of singular values affects the quality of the compressed image. Implement a Python script to compress a grayscale image using Truncated SVD and visualize the compression quality.\n\nTruncated SVD: Decomposes an image A into U, S, and V matrices. The compressed image is reconstructed using a subset of singular values.\nMathematical Representation: \n  A \\approx U_k \\Sigma_k V_k^T\n  \n\nU_k and V_k are the first k columns of U and V, respectively.\n\\Sigma_k is a diagonal matrix with the top k singular values.\nRelative Error: Measures the fidelity of the compressed image compared to the original. \n  \\text{Relative Error} = \\frac{\\| A - A_k \\|}{\\| A \\|}\n  \n\n\nimport matplotlib.pyplot as plt\nimport matplotlib.animation as animation\nimport numpy as np\nfrom skimage import io, color\nimport requests\nfrom io import BytesIO\n\ndef download_image(url):\n    response = requests.get(url)\n    img = io.imread(BytesIO(response.content))\n    return color.rgb2gray(img)  # Convert to grayscale\n\ndef update_plot(i, img_plot, error_plot, U, S, V, original_img, errors, ranks, ax1, ax2):\n    # Adjust rank based on the frame index\n    if i &lt; 70:\n        rank = i + 1\n    else:\n        rank = 70 + (i - 69) * 10\n\n    reconstructed_img = ... # YOUR CODE HERE \n\n    # Calculate relative error\n    relative_error = ... # YOUR CODE HERE\n    errors.append(relative_error)\n    ranks.append(rank)\n\n    # Update the image plot and title\n    img_plot.set_data(reconstructed_img)\n    ax1.set_title(f\"Image compression with SVD\\n Rank {rank}; Relative error {relative_error:.2f}\")\n\n    # Remove axis ticks and labels from the first subplot (ax1)\n    ax1.set_xticks([])\n    ax1.set_yticks([])\n\n    # Update the error plot\n    error_plot.set_data(ranks, errors)\n    ax2.set_xlim(1, len(S))\n    ax2.grid(linestyle=\":\")\n    ax2.set_ylim(1e-4, 0.5)\n    ax2.set_ylabel('Relative Error')\n    ax2.set_xlabel('Rank')\n    ax2.set_title('Relative Error over Rank')\n    ax2.semilogy()\n\n    # Set xticks to show rank numbers\n    ax2.set_xticks(range(1, len(S)+1, max(len(S)//10, 1)))  # Adjust the step size as needed\n    plt.tight_layout()\n\n    return img_plot, error_plot\n\n\ndef create_animation(image, filename='svd_animation.mp4'):\n    U, S, V = np.linalg.svd(image, full_matrices=False)\n    errors = []\n    ranks = []\n\n    fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(5, 8))\n    img_plot = ax1.imshow(image, cmap='gray', animated=True)\n    error_plot, = ax2.plot([], [], 'r-', animated=True)  # Initial empty plot for errors\n\n    # Add watermark\n    ax1.text(1, 1.02, '@fminxyz', transform=ax1.transAxes, color='gray', va='bottom', ha='right', fontsize=9)\n\n    # Determine frames for the animation\n    initial_frames = list(range(70))  # First 70 ranks\n    subsequent_frames = list(range(70, len(S), 10))  # Every 10th rank after 70\n    frames = initial_frames + subsequent_frames\n\n    ani = animation.FuncAnimation(fig, update_plot, frames=len(frames), fargs=(img_plot, error_plot, U, S, V, image, errors, ranks, ax1, ax2), interval=50, blit=True)\n    ani.save(filename, writer='ffmpeg', fps=8, dpi=300)\n\n    # URL of the image\n    url = \"\"\n\n    # Download the image and create the animation\n    image = download_image(url)\n    create_animation(image)\n\n\n\nConvergence rates\n\n[6 points] Determine (it means to prove the character of convergence if it is convergent) the convergence or divergence of a given sequences\n\nr_{k} = \\frac{1}{\\sqrt{k+5}}.\nr_{k} = 0.101^k.\nr_{k} = 0.101^{2^k}.\n\n[8 points] Let the sequence \\{r_k\\} be defined by \nr_{k+1} =\n\\begin{cases}\n\\frac{1}{2}\\,r_k, & \\text{if } k \\text{ is even}, \\\\\nr_k^2, & \\text{if } k \\text{ is odd},\n\\end{cases}\n with initial value 0 &lt; r_0 &lt; 1. Prove that \\{r_k\\} converges to 0 and analyze its convergence rate. In your answer, determine whether the overall convergence is linear, superlinear, or quadratic.\n[6 points] Determine the following sequence \\{r_k\\} by convergence rate (linear, sublinear, superlinear). In the case of superlinear convergence, determine whether there is quadratic convergence. \nr_k = \\dfrac{1}{k!}\n\n[8 points] Consider the recursive sequence defined by \nr_{k+1} = \\lambda\\,r_k + (1-\\lambda)\\,r_k^p,\\quad k\\ge0,\n where \\lambda\\in [0,1) and p&gt;1. Which additional conditions on r_0 should be satisfied for the sequence to converge? Show that when \\lambda&gt;0 the sequence converges to 0 with a linear rate (with asymptotic constant \\lambda), and when \\lambda=0 determine the convergence rate in terms of p. In particular, for p=2 decide whether the convergence is quadratic.\n\n\n\nLine search\n\n[10 points] Consider a strongly convex quadratic function f: \\mathbb{R}^n \\rightarrow \\mathbb{R}, and let us start from a point x_k \\in \\mathbb{R}^n moving in the direction of the antigradient -\\nabla f(x_k), note that \\nabla f(x_k)\\neq 0. Show that the minimum of f along this direction as a function of the step size \\alpha, for a decreasing function at x_k, satisfies Armijo‚Äôs condition for any c_1 in the range 0 \\leq c_1 \\leq \\frac{1}{2}. Specifically, demonstrate that the following inequality holds at the optimal \\alpha^*: \n\\varphi(\\alpha) = f(x_{k+1}) = f(x_k - \\alpha \\nabla f(x_k)) \\leq f(x_k) - c_1 \\alpha \\|\\nabla f(x_k)\\|_2^2\n\nImplementing and Testing Line Search Conditions in Gradient Descent [36 points] \nx_{k+1} = x_k - \\alpha \\nabla f(x_k)\n In this assignment, you will modify an existing Python code for gradient descent to include various line search conditions. You will test these modifications on two functions: a quadratic function and the Rosenbrock function. The main objectives are to understand how different line search strategies influence the convergence of the gradient descent algorithm and to compare their efficiencies based on the number of function evaluations.\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.optimize import minimize_scalar\nnp.random.seed(214)\n\n# Define the quadratic function and its gradient\ndef quadratic_function(x, A, b):\n    return 0.5 * np.dot(x.T, np.dot(A, x)) - np.dot(b.T, x)\n\ndef grad_quadratic(x, A, b):\n    return np.dot(A, x) - b\n\n# Generate a 2D quadratic problem with a specified condition number\ndef generate_quadratic_problem(cond_number):\n    # Random symmetric matrix\n    M = np.random.randn(2, 2)\n    M = np.dot(M, M.T)\n\n    # Ensure the matrix has the desired condition number\n    U, s, V = np.linalg.svd(M)\n    s = np.linspace(cond_number, 1, len(s))  # Spread the singular values\n    A = np.dot(U, np.dot(np.diag(s), V))\n\n    # Random b\n    b = np.random.randn(2)\n\n    return A, b\n\n# Gradient descent function\ndef gradient_descent(start_point, A, b, stepsize_func, max_iter=100):\n    x = start_point.copy()\n    trajectory = [x.copy()]\n\n    for i in range(max_iter):\n        grad = grad_quadratic(x, A, b)\n        step_size = stepsize_func(x, grad)\n        x -= step_size * grad\n        trajectory.append(x.copy())\n\n    return np.array(trajectory)\n\n# Backtracking line search strategy using scipy\ndef backtracking_line_search(x, grad, A, b, alpha=0.3, beta=0.8):\n    def objective(t):\n        return quadratic_function(x - t * grad, A, b)\n    res = minimize_scalar(objective, method='golden')\n    return res.x\n\n# Generate ill-posed problem\ncond_number = 30\nA, b = generate_quadratic_problem(cond_number)\n\n# Starting point\nstart_point = np.array([1.0, 1.8])\n\n# Perform gradient descent with both strategies\ntrajectory_fixed = gradient_descent(start_point, A, b, lambda x, g: 5e-2)\ntrajectory_backtracking = gradient_descent(start_point, A, b, lambda x, g: backtracking_line_search(x, g, A, b))\n\n# Plot the trajectories on a contour plot\nx1, x2 = np.meshgrid(np.linspace(-2, 2, 400), np.linspace(-2, 2, 400))\nZ = np.array([quadratic_function(np.array([x, y]), A, b) for x, y in zip(x1.flatten(), x2.flatten())]).reshape(x1.shape)\n\nplt.figure(figsize=(10, 8))\nplt.contour(x1, x2, Z, levels=50, cmap='viridis')\nplt.plot(trajectory_fixed[:, 0], trajectory_fixed[:, 1], 'o-', label='Fixed Step Size')\nplt.plot(trajectory_backtracking[:, 0], trajectory_backtracking[:, 1], 'o-', label='Backtracking Line Search')\n\n# Add markers for start and optimal points\nplt.plot(start_point[0], start_point[1], 'ro', label='Start Point')\noptimal_point = np.linalg.solve(A, b)\nplt.plot(optimal_point[0], optimal_point[1], 'y*', markersize=15, label='Optimal Point')\n\nplt.legend()\nplt.title('Gradient Descent Trajectories on Quadratic Function')\nplt.xlabel('x1')\nplt.ylabel('x2')\nplt.savefig(\"linesearch.svg\")\nplt.show()\n\n\n\nThe code above plots this\n\n\nStart by reviewing the provided Python code. This code implements gradient descent with a fixed step size and a backtracking line search on a quadratic function. Familiarize yourself with how the gradient descent function and the step size strategies are implemented.\n\n[10/36 points] Modify the gradient descent function to include the following line search conditions:\n\nDichotomy\nSufficient Decrease Condition\nWolfe Condition\nPolyak step size \n\\alpha_k = \\frac{f(x_k) - f^*}{\\|\\nabla f(x_k)\\|_2^2},\n where f^* is the optimal value of the function. It seems strange to use the optimal value of the function in the step size, but there are options to estimate it even without knowing the optimal value.\n\nSign Gradient Method: \n\\alpha_k = \\frac{1}{\\|\\nabla f(x_k)\\|_2},\n Test your modified gradient descent algorithm with the implemented step size search conditions on the provided quadratic function. Plot the trajectories over iterations for each condition. Choose and specify hyperparameters for inexact line search conditions. Choose and specify the termination criterion. Start from the point x_0 = (-1, 2)^T.\n\n[8/36 points] Compare these 7 methods from the budget perspective. Plot the graph of function value from the number of function evaluations for each method on the same graph.\n[10/36 points] Plot trajectory for another function with the same set of methods \nf(x_1, x_2) =  10(x_2 ‚àí x_1^2)^2 + (x_1 ‚àí 1)^2\n with x_0 = (-1, 2)^T. You might need to adjust hyperparameters.\n[8/36 points] Plot the same function value from the number of function calls for this experiment.\n\n\n\n\nMatrix calculus\n\n[6 points] Find the gradient \\nabla f(x) and hessian f^{\\prime\\prime}(x), if f(x) = \\frac{1}{2}\\Vert A - xx^T\\Vert ^2_F, A \\in \\mathbb{S}^n\n[6 points] Find the gradient \\nabla f(x) and hessian f''(x), if f(x) = \\dfrac{1}{2} \\Vert Ax - b\\Vert^2_2.\n[8 points] Find the gradient \\nabla f(x) and hessian f''(x), if \nf(x) = \\frac1m \\sum\\limits_{i=1}^m \\log \\left( 1 + \\exp(a_i^{T}x) \\right) + \\frac{\\mu}{2}\\Vert x\\Vert _2^2, \\; a_i, x \\in \\mathbb R^n, \\; \\mu&gt;0\n\n[8 points] Compute the gradient \\nabla_A f(A) of the trace of the matrix exponential function f(A) = \\text{tr}(e^A) with respect to A. Hint: Use the definition of the matrix exponential. Use the definition of the differential df = f(A + dA) - f(A) + o(\\Vert dA \\Vert) with the limit \\Vert dA \\Vert \\to 0.\n[20 points] Principal Component Analysis through gradient calculation. Let there be a dataset \\{x_i\\}_{i=1}^N, x_i \\in \\mathbb{R}^D, which we want to transform into a dataset of reduced dimensionality d using projection onto a linear subspace defined by the matrix P \\in \\mathbb{R}^{D \\times d}. The orthogonal projection of a vector x onto this subspace can be computed as P(P^TP)^{-1}P^Tx. To find the optimal matrix P, consider the following optimization problem: \nF(P) = \\sum_{i=1}^N \\|x_i - P(P^TP)^{-1}P^Tx_i\\|^2 = N \\cdot \\text{tr}\\left((I - P(P^TP)^{-1}P^T)^2 S\\right) \\to \\min_{P \\in \\mathbb{R}^{D \\times d}},\n where S = \\frac{1}{N} \\sum_{i=1}^N x_i x_i^T is the sample covariance matrix for the normalized dataset.\n\nFind the gradient \\nabla_P F(P), calculated for an arbitrary matrix P with orthogonal columns, i.e., P : P^T P = I.\nHint: When calculating the differential dF(P), first treat P as an arbitrary matrix, and then use the orthogonality property of the columns of P in the resulting expression.\nConsider the eigendecomposition of the matrix S: \nS = Q \\Lambda Q^T,\n where \\Lambda is a diagonal matrix with eigenvalues on the diagonal, and Q = [q_1 | q_2 | \\ldots | q_D] \\in \\mathbb{R}^{D \\times D} is an orthogonal matrix consisting of eigenvectors q_i as columns. Prove the following:\n\nThe gradient \\nabla_P F(P) equals zero for any matrix P composed of d distinct eigenvectors q_i as its columns.\nThe minimum value of F(P) is achieved for the matrix P composed of eigenvectors q_i corresponding to the largest eigenvalues of S.\n\n\n\n\n\nAutomatic differentiation and jax\n\nBenchmarking Hessian-Vector Product (HVP) Computation in a Neural Network via JAX [22 points]\nYou are given a simple neural network model (an MLP with several hidden layers using a nonlinearity such as GELU). The model‚Äôs parameters are defined by the weights of its layers. Your task is to compare different approaches for computing the Hessian-vector product (HVP) with respect to the model‚Äôs loss and to study how the computation time scales as the model grows in size.\nModel and Loss Definition: [2/22 points] Here is the code for the model and loss definition. Write a method get_params() that returns the flattened vector of all model weights.\nimport jax\nimport jax.numpy as jnp\nimport time\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\nfrom tqdm.auto import tqdm\nfrom jax.nn import gelu\n\n# –û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ MLP –º–æ–¥–µ–ª–∏\nclass MLP:\n    def __init__(self, key, layer_sizes):\n        self.layer_sizes = layer_sizes\n        keys = jax.random.split(key, len(layer_sizes) - 1)\n        self.weights = [\n            jax.random.normal(k, (layer_sizes[i], layer_sizes[i + 1]))\n            for i, k in enumerate(keys)\n            ]\n\n    def forward(self, x):\n        for w in self.weights[:-1]:\n            x = gelu(jnp.dot(x, w))\n        return jnp.dot(x, self.weights[-1])\n\n    def get_params(self):\n        ### YOUR CODE HERE ###\n        return None\nHessian and HVP Implementations: [2/22 points] Write a function\n# –§—É–Ω–∫—Ü–∏—è –¥–ª—è –≤—ã—á–∏—Å–ª–µ–Ω–∏—è –ì–µ—Å—Å–∏–∞–Ω–∞\ndef calculate_hessian(model, params):\n    def loss_fn(p):\n        x = jnp.ones((1, model.layer_sizes[0]))  # –ó–∞–≥–ª—É—à–∫–∞ –≤—Ö–æ–¥–∞\n        return jnp.sum(model.forward(x))\n\n    ### YOUR CODE HERE ###\n    #hessian_fn =           \n    return hessian_fn(params)\nthat computes the full Hessian H of the loss function with respect to the model parameters using JAX‚Äôs automatic differentiation.\nNaive HVP via Full Hessian: [2/22 points] Write a function naive_hvp(hessian, vector) that, given a precomputed Hessian H and a vector v (of the same shape as the parameters), computes the Hessian-vector product using a straightforward matrix-vector multiplication.\nEfficient HVP Using Autograd: [4/22 points] Write a function python   def hvp(f, x, v):       return jax.grad(lambda x: jnp.vdot(jax.grad(f)(x), v))(x) that directly computes the HVP without explicitly forming the full Hessian. This leverages the reverse-mode differentiation capabilities of JAX.\nTiming Experiment: Consider a family of models with an increasing number of hidden layers.\nns = np.linspace(50, 1000, 15, dtype=int)  # The number of hidden layers\nnum_runs = 10  # The number of runs for averaging\nFor each model configuration:\n\nGenerate the model and extract its parameter vector.\nGenerate a random vector v of the same dimension as the parameters.\nMeasure (do not forget to use .block_until_ready() to ensure accurate timing and proper synchronization) the following:\n\nCombined Time (Full Hessian + Naive HVP): The total time required to compute the full Hessian and then perform the matrix-vector multiplication.\nNaive HVP Time (Excluding Hessian Computation): The time required to perform the matrix-vector multiplication given a precomputed Hessian.\nEfficient HVP Time: The time required to compute the HVP using the autograd-based function.\n\nRepeat each timing measurement for a fixed number of runs (e.g., 10 runs) and record both the mean and standard deviation of the computation times.\n\nVisualization and Analysis: [12/22 points]\n\nPlot the timing results for the three methods on the same graph. For each method, display error bars corresponding to the standard deviation over the runs.\nLabel the axes clearly (e.g., ‚ÄúNumber of Layers‚Äù vs.¬†‚ÄúComputation Time (seconds)‚Äù) and include a legend indicating which curve corresponds to which method.\nAnalyze the scaling behavior. Try analytically derive the scaling of the methods and compare it with the experimental results.\n\n[15 points] We can use automatic differentiation not only to calculate necessary gradients but also for tuning hyperparameters of the algorithm like learning rate in gradient descent (with gradient descent ü§Ø). Suppose, we have the following function f(x) = \\frac{1}{2}\\Vert x\\Vert^2, select a random point x_0 \\in \\mathbb{B}^{1000} = \\{0 \\leq x_i \\leq 1 \\mid \\forall i\\}. Consider 10 steps of the gradient descent starting from the point x_0: \nx_{k+1} = x_k - \\alpha_k \\nabla f(x_k)\n Your goal in this problem is to write the function, that takes 10 scalar values \\alpha_i and return the result of the gradient descent on function L = f(x_{10}). And optimize this function using gradient descent on \\alpha \\in \\mathbb{R}^{10}. Suppose that each of 10 components of \\alpha is uniformly distributed on [0; 0.1]. \n\\alpha_{k+1} = \\alpha_k - \\beta \\frac{\\partial L}{\\partial \\alpha}\n Choose any constant \\beta and the number of steps you need. Describe the obtained results. How would you understand, that the obtained schedule (\\alpha \\in \\mathbb{R}^{10}) becomes better than it was at the start? How do you check numerically local optimality in this problem?\n\n\n\nConvexity\n\n[10 points] Show that this function is convex.: \nf(x, y, z) = z \\log \\left(e^{\\frac{x}{z}} + e^{\\frac{y}{z}}\\right) + (z - 2)^2 + e^{\\frac{1}{x + y}}\n where the function f : \\mathbb{R}^3 \\to \\mathbb{R} has its domain defined as: \n\\text{dom } f = \\{ (x, y, z) \\in \\mathbb{R}^3 : x + y &gt; 0, \\, z &gt; 0 \\}.\n\n[5 points] The center of mass of a body is an important concept in physics (mechanics). For a system of material points with masses m_i and coordinates x_i, the center of mass is given by: \nx_c = \\frac{\\sum_{i=1}^k m_i x_i}{\\sum_{i=1}^k m_i}\n The center of mass of a body does not always lie inside the body. For example, the center of mass of a doughnut is located in its hole. Prove that the center of mass of a system of material points lies in the convex hull of the set of these points.\n[8 points] Show, that \\mathbf{conv}\\{xx^\\top: x \\in \\mathbb{R}^n, \\Vert x\\Vert  = 1\\} = \\{A \\in \\mathbb{S}^n_+: \\text{tr}(A) = 1\\}.\n[5 points] Prove that the set of \\{x \\in \\mathbb{R}^2 \\mid e^{x_1}\\le x_2\\} is convex.\n[8 points] Consider the function f(x) = x^d, where x \\in \\mathbb{R}_{+}. Fill the following table with ‚úÖ or ‚ùé. Explain your answers (with proofs).\n\n\n\n\nd\nConvex\nConcave\nStrictly Convex\n\\mu-strongly convex\n\n\n\n\n-2, x \\in \\mathbb{R}_{++}\n\n\n\n\n\n\n-1, x \\in \\mathbb{R}_{++}\n\n\n\n\n\n\n0\n\n\n\n\n\n\n0.5\n\n\n\n\n\n\n1\n\n\n\n\n\n\n\\in (1; 2)\n\n\n\n\n\n\n2\n\n\n\n\n\n\n&gt; 2\n\n\n\n\n\n\n\n\n[6 points] Prove that the entropy function, defined as \nf(x) = -\\sum_{i=1}^n x_i \\log(x_i),\n with \\text{dom}(f) = \\{x \\in \\R^n_{++} : \\sum_{i=1}^n x_i = 1\\}, is strictly concave.\n[8 points] Show that the maximum of a convex function f over the polyhedron P = \\text{conv}\\{v_1, \\ldots, v_k\\} is achieved at one of its vertices, i.e., \n\\sup_{x \\in P} f(x) = \\max_{i=1, \\ldots, k} f(v_i).\n\nA stronger statement is: the maximum of a convex function over a closed bounded convex set is achieved at an extreme point, i.e., a point in the set that is not a convex combination of any other points in the set. (you do not have to prove it). Hint: Assume the statement is false, and use Jensen‚Äôs inequality.\n[6 points] Show, that the two definitions of \\mu-strongly convex functions are equivalent:\n\nf(x) is \\mu-strongly convex \\iff for any x_1, x_2 \\in S and 0 \\le \\lambda \\le 1 for some \\mu &gt; 0: \nf(\\lambda x_1 + (1 - \\lambda)x_2) \\le \\lambda f(x_1) + (1 - \\lambda)f(x_2) - \\frac{\\mu}{2} \\lambda (1 - \\lambda)\\|x_1 - x_2\\|^2\n\nf(x) is \\mu-strongly convex \\iff if there exists \\mu&gt;0 such that the function f(x) - \\dfrac{\\mu}{2}\\Vert x\\Vert^2 is convex.\n\n\n\n\nOptimality conditions. KKT. Duality\nIn this section, you can consider either the arbitrary norm or the Euclidian norm if nothing else is specified.\n\nToy example [10 points] \n\\begin{split}\n& x^2 + 1 \\to \\min\\limits_{x \\in \\mathbb{R} }\\\\\n\\text{s.t. } & (x-2)(x-4) \\leq 0\n\\end{split}\n\n\nGive the feasible set, the optimal value, and the optimal solution.\nPlot the objective x^2 +1 versus x. On the same plot, show the feasible set, optimal point, and value, and plot the Lagrangian L(x,\\mu) versus x for a few positive values of \\mu. Verify the lower bound property (p^* \\geq \\inf_x L(x, \\mu)for \\mu \\geq 0). Derive and sketch the Lagrange dual function g.\nState the dual problem, and verify that it is a concave maximization problem. Find the dual optimal value and dual optimal solution \\mu^*. Does strong duality hold?\nLet p^*(u) denote the optimal value of the problem\n\n\n\\begin{split}\n& x^2 + 1 \\to \\min\\limits_{x \\in \\mathbb{R} }\\\\\n\\text{s.t. } & (x-2)(x-4) \\leq u\n\\end{split}\n\nas a function of the parameter u. Plot p^*(u). Verify that \\dfrac{dp^*(0)}{du} = -\\mu^*\nConsider a smooth convex function f(x) at some point x_k. One can define the first-order Taylor expansion of the function as: \nf^I_{x_k}(x) = f(x_k) + \\nabla f(x_k)^\\top (x - x_k),\n where we can define \\delta x = x - x_k and g = \\nabla f(x_k). Thus, the expansion can be rewritten as: \nf^I_{x_k}(\\delta x) = f(x_k) + g^\\top \\delta x.\n Suppose, we would like to design the family of optimization methods that will be defined as: \nx_{k+1} = \\text{arg}\\min_{x} \\left\\{f^I_{x_k}(\\delta x) + \\frac{\\lambda}{2} \\|\\delta x\\|^2\\right\\},\n where \\lambda &gt; 0 is a parameter.\n\n[5 points] Show, that this method is equivalent to the gradient descent method with the choice of Euclidean norm of the vector \\|\\delta x\\| = \\|\\delta x\\|_2. Find the corresponding learning rate.\n[5 points] Prove, that the following holds: \n\\text{arg}\\min_{\\delta x \\in \\mathbb{R}^n} \\left\\{ g^T\\delta x + \\frac{\\lambda}{2} \\|\\delta x\\|^2\\right\\} = - \\frac{\\|g\\|_*}{\\lambda} \\text{arg}\\max_{\\|t\\|=1} \\left\\{ t^T g \\right\\},\n where \\|g\\|_* is the dual norm of g.\n[3 points] Consider another vector norm \\|\\delta x\\| = \\|\\delta x\\|_\\infty. Write down explicit expression for the corresponding method.\n[2 points] Consider induced operator matrix norm for any matrix W \\in \\mathbb{R}^{d_{out} \\times d_{in}} \n\\|W\\|_{\\alpha \\to \\beta} = \\max_{x \\in \\mathbb{R}^{d_{in}}} \\frac{\\|Wx\\|_{\\beta}}{\\|x\\|_{\\alpha}}.\n Typically, when we solve optimization problems in deep learning, we stack the weight matrices for all layers l = [1, L] into a single vector. \nw = \\text{vec}(W_1, W_2, \\ldots, W_L) \\in \\mathbb{R}^{n},\n Can you write down the explicit expression, that relates \n\\|w\\|_\\infty \\qquad \\text{ and } \\qquad \\|W_l\\|_{\\alpha \\to \\beta}, \\; l = [1, L]?\n\n\n[10 points] Derive the dual problem for the Ridge regression problem with A \\in \\mathbb{R}^{m \\times n}, b \\in \\mathbb{R}^m, \\lambda &gt; 0:\n\n\\begin{split}\n\\dfrac{1}{2}\\|y-b\\|^2 + \\dfrac{\\lambda}{2}\\|x\\|^2 &\\to \\min\\limits_{x \\in \\mathbb{R}^n, y \\in \\mathbb{R}^m }\\\\\n\\text{s.t. } & y = Ax\n\\end{split}\n\n[20 points] Derive the dual problem for the support vector machine problem with A \\in \\mathbb{R}^{m \\times n}, \\mathbf{1} \\in \\mathbb{R}^m \\in \\mathbb{R}^m, \\lambda &gt; 0:\n\n\\begin{split}\n\\langle \\mathbf{1}, t\\rangle + \\dfrac{\\lambda}{2}\\|x\\|^2 &\\to \\min\\limits_{x \\in \\mathbb{R}^n, t \\in \\mathbb{R}^m }\\\\\n\\text{s.t. } & Ax \\succeq \\mathbf{1} - t \\\\\n& t \\succeq 0\n\\end{split}\n\n[10 points] Give an explicit solution to the following LP.\n\n\\begin{split}\n& c^\\top x \\to \\min\\limits_{x \\in \\mathbb{R}^n }\\\\\n\\text{s.t. } & 1^\\top x = 1, \\\\\n& x \\succeq 0\n\\end{split}\n\nThis problem can be considered the simplest portfolio optimization problem.\n[20 points] Show, that the following problem has a unique solution and find it:\n\n\\begin{split}\n& \\langle C^{-1}, X\\rangle - \\log \\det X \\to \\min\\limits_{x \\in \\mathbb{R}^{n \\times n} }\\\\\n\\text{s.t. } & \\langle Xa, a\\rangle \\leq 1,\n\\end{split}\n\nwhere C \\in \\mathbb{S}^n_{++}, a \\in \\mathbb{R}^n \\neq 0. The answer should not involve inversion of the matrix C.\n[20 points] Give an explicit solution to the following QP.\n\n\\begin{split}\n& c^\\top x \\to \\min\\limits_{x \\in \\mathbb{R}^n }\\\\\n\\text{s.t. } & (x - x_c)^\\top A (x - x_c) \\leq 1,\n\\end{split}\n\nwhere A \\in \\mathbb{S}^n_{++}, c \\neq 0, x_c \\in \\mathbb{R}^n.\n[10 points] Consider the equality-constrained least-squares problem\n\n\\begin{split}\n& \\|Ax - b\\|_2^2 \\to \\min\\limits_{x \\in \\mathbb{R}^n }\\\\\n\\text{s.t. } & Cx = d,\n\\end{split}\n\nwhere A \\in \\mathbb{R}^{m \\times n} with \\mathbf{rank }A = n, and C \\in \\mathbb{R}^{k \\times n} with \\mathbf{rank }C = k. Give the KKT conditions, and derive expressions for the primal solution x^* and the dual solution \\lambda^*.\nSupporting hyperplane interpretation of KKT conditions. [10 points] Consider a convex problem with no equality constraints\n\n\\begin{split}\n& f_0(x) \\to \\min\\limits_{x \\in \\mathbb{R}^n }\\\\\n\\text{s.t. } & f_i(x) \\leq 0, \\quad i = [1,m]\n\\end{split}\n\nAssume, that \\exists x^* \\in \\mathbb{R}^n, \\mu^* \\in \\mathbb{R}^m satisfy the KKT conditions\n\n\\begin{split}\n& \\nabla_x L (x^*, \\mu^*) = \\nabla f_0(x^*) + \\sum\\limits_{i=1}^m\\mu_i^*\\nabla f_i(x^*) = 0 \\\\\n& \\mu^*_i \\geq 0, \\quad i = [1,m] \\\\\n& \\mu^*_i f_i(x^*) = 0, \\quad i = [1,m]\\\\\n& f_i(x^*) \\leq 0, \\quad i = [1,m]\n\\end{split}\n\nShow that\n\n\\nabla f_0(x^*)^\\top (x - x^*) \\geq 0\n\nfor all feasible x. In other words, the KKT conditions imply the simple optimality criterion or \\nabla f_0(x^*) defines a supporting hyperplane to the feasible set at x^*.\nA penalty method for equality constraints. [10 points] We consider the problem of minimization\n\n\\begin{split}\n& f_0(x) \\to \\min\\limits_{x \\in \\mathbb{R}^{n} }\\\\\n\\text{s.t. } & Ax = b,\n\\end{split}\n\nwhere $f_0(x): ^n $ is convex and differentiable, and A \\in \\mathbb{R}^{m \\times n} with \\mathbf{rank }A = m. In a quadratic penalty method, we form an auxiliary function\n\n\\phi(x) = f_0(x) + \\alpha \\|Ax - b\\|_2^2,\n\nwhere \\alpha &gt; 0 is a parameter. This auxiliary function consists of the objective plus the penalty term \\alpha \\Vert Ax - b\\Vert_2^2. The idea is that a minimizer of the auxiliary function, \\tilde{x}, should be an approximate solution to the original problem. Intuition suggests that the larger the penalty weight \\alpha, the better the approximation \\tilde{x} to a solution of the original problem. Suppose \\tilde{x} is a minimizer of \\phi(x). Show how to find, from \\tilde{x}, a dual feasible point for the original problem. Find the corresponding lower bound on the optimal value of the original problem.\n\n\n\nLinear programming\n\nüì±üéßüíª Covers manufacturing. [20 points] Lyzard Corp is producing covers for the following products:\n\nüì± phones\nüéß headphones\nüíª laptops\n\nThe company‚Äôs production facilities are such that if we devote the entire production to headphone covers, we can produce 5000 of them in one day. If we devote the entire production to phone covers or laptop covers, we can produce 4000 or 2000 of them in one day.\nThe production schedule is one week (6 working days), and the week‚Äôs production must be stored before distribution. Storing 1000 headphone covers (packaging included) takes up 30 cubic feet of space. Storing 1000 phone covers (packaging included) takes up 50 cubic feet of space, and storing 1000 laptop covers (packaging included) takes up 200 cubic feet of space. The total storage space available is 1500 cubic feet.\nDue to commercial agreements with Lyzard Corp has to deliver at least 6000 headphone covers and 4000 laptop covers per week to strengthen the product‚Äôs diffusion.\nThe marketing department estimates that the weekly demand for headphones covers, phone, and laptop covers does not exceed 15000, 12000 and 8000 units, therefore the company does not want to produce more than these amounts for headphones, phone, and laptop covers.\nFinally, the net profit per headphone cover, phone cover, and laptop cover are $5, $7, and $12, respectively.\nThe aim is to determine a weekly production schedule that maximizes the total net profit.\n\nWrite a Linear Programming formulation for the problem. Use the following variables:\n\ny_1 = number of headphones covers produced over the week,\n\ny_2 = number of phone covers produced over the week,\n\ny_3 = number of laptop covers produced over the week.\n\nFind the solution to the problem using PyOMO\n!pip install pyomo\n! sudo apt-get install glpk-utils --quiet  # GLPK\n! sudo apt-get install coinor-cbc --quiet  # CoinOR\nPerform the sensitivity analysis. Which constraint could be relaxed to increase the profit the most? Prove it numerically.\n\nProve the optimality of the solution [10 points]\n\nx = \\left(\\frac{7}{3} , 0, \\frac{1}{3}\\right)^T\n\nto the following linear programming problem:\n\n\\begin{split}\n& 9x_1 + 3x_2 + 7x_3 \\to \\max\\limits_{x \\in \\mathbb{R}^3 }\\\\\n\\text{s.t. } & 2x_1 + x_2 + 3x_3 \\leq 6 \\\\\n& 5x_1 + 4x_2 + x_3 \\leq 12 \\\\\n& 3x_3 \\leq 1,\\\\\n& x_1, x_2, x_3 \\geq 0\n\\end{split}\n\nbut you cannot use any numerical algorithm here.\n[10 points] Economic interpretation of the dual problem: Suppose a small shop makes wooden toys, where each toy train requires one piece of wood and 2 tins of paint, while each toy boat requires one piece of wood and 1 tin of paint. The profit on each toy train is \\$30, and the profit on each toy boat is \\$20. Given an inventory of 80 pieces of wood and 100 tins of paint, how many of each toy should be made to maximize the profit?\n\nWrite out the optimization problem in standard form, writing all constraints as inequalities.\nSketch the feasible set and determine p^* and x^*\nFind the dual problem, then determine d^* and \\lambda^*. Note that we can interpret the Lagrange multipliers \\lambda_k associated with the constraints on wood and paint as the prices for each piece of wood and tin of paint, so that ‚àíd^* is how much money would be obtained from selling the inventory for those prices. Strong duality says a buyer should not pay more for the inventory than what the toy store would make by producing and selling toys from it, and that the toy store should not sell the inventory for less than that.\nThe other interpretation of the Lagrange multipliers is as sensitivities to changes in the constraints. Suppose the toymaker found some more pieces of wood; the \\lambda_k associated with the wood constraint will equal the partial derivative of ‚àíp^* with respect to how much more wood became available. Suppose the inventory increases by one piece of wood. Use \\lambda^* to estimate how much the profit would increase, without solving the updated optimization problem. How is this consistent with the price interpretation given above for the Lagrange multipliers? source\n\n\n\n\nGradient Descent\n\nConvergence of Gradient Descent in non-convex smooth case [10 points]\nWe will assume nothing about the convexity of f. We will show that gradient descent reaches an \\varepsilon-substationary point x, such that \\|\\nabla f(x)\\|_2 \\leq \\varepsilon, in O(1/\\varepsilon^2) iterations. Important note: you may use here Lipschitz parabolic upper bound:\n\nf(y) \\leq f(x) + \\nabla f(x)^T (y-x) + \\frac{L}{2} \\|y-x\\|_2^2, \\;\\;\\;\n\\text{for all $x,y$}.  \n  \\tag{1}\n\nPlug in y = x^{k+1} = x^{k} - \\alpha \\nabla f(x^k), x = x^k to (–£—Ä–∞–≤–Ω–µ–Ω–∏–µ¬†1) to show that\n\n  f(x^{k+1}) \\leq f(x^k) - \\Big (1-\\frac{L\\alpha}{2} \\Big) \\alpha \\|\\nabla f(x^k)\\|_2^2.\n  \nUse \\alpha \\leq 1/L, and rearrange the previous result, to get\n\n  \\|\\nabla f(x^k)\\|_2^2 \\leq \\frac{2}{\\alpha} \\left( f(x^k) - f(x^{k+1}) \\right).\n  \nSum the previous result over all iterations from 1,\\ldots,k+1 to establish\n\n  \\sum_{i=0}^k \\|\\nabla f(x^{i})\\|_2^2 \\leq\n  \\frac{2}{\\alpha} ( f(x^{0}) - f^*).\n  \nLower bound the sum in the previous result to get\n\n  \\min_{i=0,\\ldots,k} \\|\\nabla f(x^{i}) \\|_2\n  \\leq \\sqrt{\\frac{2}{\\alpha(k+1)} (f(x^{0}) - f^*)},\n   which establishes the desired O(1/\\varepsilon^2) rate for achieving \\varepsilon-substationarity.\n\nHow gradient descent convergence depends on the condition number and dimensionality. [20 points] Investigate how the number of iterations required for gradient descent to converge depends on the following two parameters: the condition number \\kappa \\geq 1 of the function being optimized, and the dimensionality n of the space of variables being optimized.\nTo do this, for given parameters n and \\kappa, randomly generate a quadratic problem of size n with condition number \\kappa and run gradient descent on it with some fixed required precision. Measure the number of iterations T(n, \\kappa) that the method required for convergence (successful termination based on the stopping criterion).\nRecommendation: The simplest way to generate a random quadratic problem of size n with a given condition number \\kappa is as follows. It is convenient to take a diagonal matrix A \\in S_{n}^{++} as simply the diagonal matrix A = \\text{Diag}(a), whose diagonal elements are randomly generated within [1, \\kappa], and where \\min(a) = 1, \\max(a) = \\kappa. As the vector b \\in \\mathbb{R}^n, you can take a vector with random elements. Diagonal matrices are convenient to consider since they can be efficiently processed with even for large values of n.\nFix a certain value of the dimensionality n. Iterate over different condition numbers \\kappa on a grid and plot the dependence of T(n,\\kappa) against \\kappa. Since the quadratic problem is generated randomly each time, repeat this experiment several times. As a result, for a fixed value of n, you should obtain a whole family of curves showing the dependence of T(n, \\kappa) on \\kappa. Draw all these curves in the same color for clarity (for example, red).\nNow increase the value of n and repeat the experiment. You should obtain a new family of curves T(n',\\kappa) against \\kappa. Draw all these curves in the same color but different from the previous one (for example, blue).\nRepeat this procedure several times for other values of n. Eventually, you should have several different families of curves - some red (corresponding to one value of n), some blue (corresponding to another value of n), some green, etc.\nNote that it makes sense to iterate over the values of the dimensionality n on a logarithmic grid (for example, n = 10, n = 100, n = 1000, etc.). Use the following stopping criterion: \\|\\nabla f(x_k)\\|_2^2 \\leq \\varepsilon \\|\\nabla f(x_0)\\|_2^2 with \\varepsilon = 10^{-5}. Select the starting point x_0 = (1, \\ldots, 1)^T\nWhat conclusions can be drawn from the resulting picture?\n\n\n\nAccelerated methods\n\nLocal Convergence of Heavy Ball Method. [20 points] We will work with the heavy ball method in this problem\n\n\\tag{HB}\nx_{k+1} = x_k - \\alpha \\nabla f(x_k) + \\beta (x_k - x_{k-1})\n\nIt is known, that for the quadratics the best choice of hyperparameters is \\alpha^* = \\dfrac{4}{(\\sqrt{L} + \\sqrt{\\mu})^2}, \\beta^* = \\dfrac{(\\sqrt{L} - \\sqrt{\\mu})^2}{(\\sqrt{L} + \\sqrt{\\mu})^2}, which ensures accelerated linear convergence for a strongly convex quadratic function.\nConsider the following continuously differentiable, strongly convex with parameter \\mu, and smooth function with parameter L:\n\nf(x) =\n\\begin{cases}\n\\frac{25}{2}x^2, & \\text{if } x &lt; 1 \\\\\n\\frac12x^2 + 24x - 12, & \\text{if } 1 \\leq x &lt; 2 \\\\\n\\frac{25}{2}x^2 - 24x + 36, & \\text{if } x \\geq 2\n\\end{cases}\n\\quad\n\\nabla f(x) =\n\\begin{cases}\n25x, & \\text{if } x &lt; 1 \\\\\nx + 24, & \\text{if } 1 \\leq x &lt; 2 \\\\\n25x - 24, & \\text{if } x \\geq 2\n\\end{cases}\n\n\nHow to prove, that the given function is convex? Strongly convex? Smooth?\nFind the constants \\mu and L for a given function.\nPlot the function value for x \\in [-4, 4].\nRun the Heavy Ball method for the function with optimal hyperparameters \\alpha^* = \\dfrac{4}{(\\sqrt{L} + \\sqrt{\\mu})^2}, \\beta^* = \\dfrac{(\\sqrt{L} - \\sqrt{\\mu})^2}{(\\sqrt{L} + \\sqrt{\\mu})^2} for quadratic function, starting from x_0 = 3.5. If you have done everything above correctly, you should receive something like\n\nYou can use the following code for plotting:\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport matplotlib.animation as animation\nfrom IPython.display import HTML\n\n# Gradient of the function\ndef grad_f(x):\n    ...\n\n# Heavy Ball method implementation\ndef heavy_ball_method(alpha, beta, x0, num_iterations):\n    x = np.zeros(num_iterations + 1)\n    x_prev = x0\n    x_curr = x0  # Initialize x[1] same as x[0] to start the algorithm\n    for i in range(num_iterations):\n        x[i] = x_curr\n        x_new = x_curr - alpha * grad_f(x_curr) + beta * (x_curr - x_prev)\n        x_prev = x_curr\n        x_curr = x_new\n    x[num_iterations] = x_curr\n    return x\n\n# Parameters\nL = ...\nmu = ...\nalpha_star = ...\nbeta_star = ...\nx0 = ...\nnum_iterations = 30\n\n# Generate the trajectory of the method\ntrajectory = heavy_ball_method(alpha_star, beta_star, x0, num_iterations)\n\n# Setup the figure and axes for the animation\nfig, (ax1, ax2) = plt.subplots(1, 2, figsize=(7, 3.5))\nfig.suptitle(\"Heavy ball method with optimal hyperparameters Œ±* Œ≤*\")\n\n# Function for updating the animation\ndef update(i):\n    ax1.clear()\n    ax2.clear()\n\n    # Plot f(x) and trajectory\n    x_vals = np.linspace(-4, 4, 100)\n    f_vals = np.piecewise(x_vals, [x_vals &lt; 1, (x_vals &gt;= 1) & (x_vals &lt; 2), x_vals &gt;= 2],\n                        [lambda x: 12.5 * x**2, lambda x: .5 * x**2 + 24 * x - 12, lambda x: 12.5 * x**2 - 24 * x + 36])\n    ax1.plot(x_vals, f_vals, 'b-')\n    ax1.plot(trajectory[:i], [12.5 * x**2 if x &lt; 1 else .5 * x**2 + 24 * x - 12 if x &lt; 2 else 12.5 * x**2 - 24 * x + 36 for x in trajectory[:i]], 'ro-')\n    # Add vertical dashed lines at x=1 and x=2 on the left subplot\n    ax1.axvline(x=1, color='navy', linestyle='--')\n    ax1.axvline(x=2, color='navy', linestyle='--')\n\n    # Plot function value from iteration\n    f_trajectory = [None for x in trajectory]\n    f_trajectory[:i] = [12.5 * x**2 if x &lt; 1 else .5 * x**2 + 24 * x - 12 if x &lt; 2 else 12.5 * x**2 - 24 * x + 36 for x in trajectory[:i]]\n    ax2.plot(range(len(trajectory)), f_trajectory, 'ro-')\n    ax2.set_xlim(0, len(trajectory))\n    ax2.set_ylim(min(f_vals), max(f_vals))\n    # Add horizontal dashed lines at f(1) and f(2) on the right subplot\n    f_1 = 12.5 * 1.0**2\n    f_2 = .5 * 2.**2 + 24 * 2. - 12\n    ax2.axhline(y=f_1, color='navy', linestyle='--')\n    ax2.axhline(y=f_2, color='navy', linestyle='--')\n\n    # ax1.set_title(\"Function f(x) and Trajectory\")\n    ax1.set_xlabel(\"x\")\n    ax1.set_ylabel(\"f(x)\")\n    ax1.grid(linestyle=\":\")\n\n    # ax2.set_title(\"Function Value from Iteration\")\n    ax2.set_xlabel(\"Iteration\")\n    ax2.set_ylabel(\"f(x)\")\n    ax2.grid(linestyle=\":\")\n\n    plt.tight_layout()\n\n# Create the animation\nani = animation.FuncAnimation(fig, update, frames=num_iterations, repeat=False, interval=100)\nHTML(ani.to_jshtml())\nChange the starting point to x_0 = 3.4. What do you see? How could you name such a behavior of the method?\nChange the hyperparameter \\alpha^{\\text{Global}} = \\frac2L, \\beta^{\\text{Global}} = \\frac{\\mu}{L} and run the method again from x_0 = 3.4. Check whether you have accelerated convergence here.\n\nContext: this counterexample was provided in the paper, while the global convergence of the heavy ball method for general smooth strongly convex function was introduced in another paper. Recently, it was suggested, that the heavy-ball (HB) method provably does not reach an accelerated convergence rate on smooth strongly convex problems.\n[40 points] In this problem we will work with accelerated methods applied to the logistic regression problem. A good visual introduction to the topic is available here.\nLogistic regression is a standard model in classification tasks. For simplicity, consider only the case of binary classification. Informally, the problem is formulated as follows: There is a training sample \\{(a_i, b_i)\\}_{i=1}^m, consisting of m vectors a_i \\in \\mathbb{R}^n (referred to as features) and corresponding numbers b_i \\in \\{-1, 1\\} (referred to as classes or labels). The goal is to construct an algorithm b(\\cdot), which for any new feature vector a automatically determines its class b(a) \\in \\{-1, 1\\}.\nIn the logistic regression model, the class determination is performed based on the sign of the linear combination of the components of the vector a with some fixed coefficients x \\in \\mathbb{R}^n:\n\nb(a) := \\text{sign}(\\langle a, x \\rangle).\n\nThe coefficients x are the parameters of the model and are adjusted by solving the following optimization problem:\n\n\\tag{LogReg}\n\\min_{x \\in \\mathbb{R}^n} \\left( \\frac{1}{m} \\sum_{i=1}^m \\ln(1 + \\exp(-b_i \\langle a_i, x \\rangle)) + \\frac{\\lambda}{2} \\|x\\|^2 \\right),\n\nwhere \\lambda \\geq 0 is the regularization coefficient (a model parameter).\n\nWill the LogReg problem be convex for \\lambda = 0? What is the gradient of the objective function? Will it be strongly convex? What if you will add regularization with \\lambda &gt; 0?\nWe will work with the real-world data for A and b: take the mushroom dataset. Be careful, you will need to predict if the mushroom is poisonous or edible. A poor model can cause death in this exercise.\nimport requests\nfrom sklearn.datasets import load_svmlight_file\n\n# URL of the file to download\nurl = 'https://hse24.fmin.xyz/files/mushrooms.txt'\n\n# Download the file and save it locally\nresponse = requests.get(url)\ndataset = 'mushrooms.txt'\n\n# Ensure the request was successful\nif response.status_code == 200:\n    with open(dataset, 'wb') as f:\n        f.write(response.content)\n\n    # Load the dataset from the downloaded file\n    data = load_svmlight_file(dataset)\n    A, b = data[0].toarray(), data[1]\n    n, d = A.shape\n\n    print(\"Data loaded successfully.\")\n    print(f\"Number of samples: {n}, Number of features: {d}\")\nelse:\n    print(f\"Failed to download the file. Status code: {response.status_code}\")\nDivide the data into two parts: training and test. We will train the model on the A_{train}, b_{train} and measure the accuracy of the model on the A_{test}, b_{test}.\nfrom sklearn.model_selection import train_test_split\n# Split the data into training and test sets\nA_train, A_test, b_train, b_test = train_test_split(A, b, test_size=0.2, random_state=214)\nFor the training part A_{train}, b_{train}, estimate the constants \\mu, L of the training/optimization problem. Use the same small value \\lambda for all experiments\nUsing gradient descent with the step \\frac{1}{L}, train a model. Plot: accuracy versus iteration number.\n\n\\tag{HB}\nx_{k+1} = x_k - \\alpha \\nabla f(x_k) + \\beta (x_k - x_{k-1})\n\nFix a step \\alpha = \\frac{1}{L} and search for different values of the momentum \\beta from -1 to 1. Choose your own convergence criterion and plot convergence for several values of momentum on the same graph. Is the convergence always monotonic?\nFor the best value of momentum \\beta, plot the dependence of the model accuracy on the test sample on the running time of the method. Add to the same graph the convergence of gradient descent with step \\frac{1}{L}. Draw a conclusion. Ensure, that you use the same value of \\lambda for both methods.\nSolve the logistic regression problem using the Nesterov method.\n\n\\tag{NAG}\nx_{k+1} = x_k - \\alpha \\nabla f(x_k + \\beta (x_k - x_{k-1})) + \\beta (x_k - x_{k-1})  \n\nFix a step \\frac{1}{L} and search for different values of momentum \\beta from -1 to 1. Check also the momentum values equal to \\frac{k}{k+3}, \\frac{k}{k+2}, \\frac{k}{k+1} (k is the number of iterations), and if you are solving a strongly convex problem, also \\frac{\\sqrt{L} - \\sqrt{\\mu}}{\\sqrt{L} + \\sqrt{\\mu}}. Plot the convergence of the method as a function of the number of iterations (choose the convergence criterion yourself) for different values of the momentum. Is the convergence always monotonic?\nFor the best value of momentum \\beta, plot the dependence of the model accuracy on the test sample on the running time of the method. Add this graph to the graphs for the heavy ball and gradient descent from the previous steps. Make a conclusion.\nNow we drop the estimated value of L and will try to do it adaptively. Let us make the selection of the constant L adaptive.\n\nf(y) \\leq f(x^k) + \\langle \\nabla f(x^k), y - x^k \\rangle + \\frac{L}{2}\\|x^k - y\\|_2^2\n\nIn particular, the procedure might work:\ndef backtracking_L(f, grad, x, h, L0, rho, maxiter=100):\n    L = L0\n    fx = f(x)\n    gradx = grad(x)\n    iter = 0\n    while iter &lt; maxiter :\n        y = x - 1 / L * h\n        if f(y) &lt;= fx - 1 / L gradx.dot(h) + 1 / (2 * L) h.dot(h):\n            break\n        else:\n            L = L * rho\n\n        iter += 1\n    return L\nWhat should h be taken as? Should \\rho be greater or less than 1? Should L_0 be taken as large or small? Draw a similar figure as it was in the previous step for L computed adaptively (6 lines - GD, HB, NAG, GD adaptive L, HB adaptive L, NAG adaptive L)\n\n\n\n\nConjugate gradients\n\nRandomized Preconditioners for Conjugate Gradient Methods. (20 points)\nLinear least squares\nIn this task, we explore the use of some randomization methods for solving overdetermined least-squares problems, focusing on conjugate gradient methods. Let \\hat{A} \\in \\mathbb{R}^{m \\times n} be a matrix (we assume that m \\gg n) and \\hat{b} \\in \\mathbb{R}^m, we aim to minimize\n\nf(x) = \\frac{1}{2} \\|\\hat{A}x - \\hat{b}\\|^2_2 = \\frac{1}{2} \\sum_{i=1}^m (\\hat{a}_i^T x - \\hat{b}_i)^2,\n\nwhere the \\hat{a}_i \\in \\mathbb{R}^n denote the rows of \\hat{A}.\nPreconditioners\nWe know, that the convergence bound of the CG applied for the problem depends on the condition number of the matrix. Note, that for the problem above we have the matrix \\hat{A}^T \\hat{A} and the condition number is squared after this operation (\\kappa (X^T X) =  \\kappa^2 \\left(X \\right)). That is the reason, why we typically need to use preconditioners (read 12. for more details) with CG.\nThe general idea of using preconditioners implies switchwing from solving Ax = b to MAx = Mb with hope, that \\kappa \\left( MA\\right) \\ll \\kappa \\left( A\\right) or eigenvalues of MA are better clustered than those of A (note, that matrix A here is for the general case, here we have \\hat{A}^T\\hat{A} instead).\nThis idea can also be viewed as coordinate change x = T \\hat{x}, \\; \\hat{x} = T^{-1}x, which leads to the problem T^T A T \\hat{x} = T^Tb. Note, that the spectrum of T^TAT is the same as the spectrum of MA.\nThe best choice of M is A^{-1}, because \\kappa (A^{-1} A) = \\kappa (I) = 1. However, if we know A^{-1}, the original problem is already solved, that is why we need to find some trade-off between enhanced convergence, and extra cost of working with M. The goal is to find M that is cheap to multiply, and approximate inverse of A (or at least has a more clustered spectrum than A).\nNote, that for the linear least squares problem the matrix of quadratic form is A = \\hat{A}^T\\hat{A} \\in \\mathbb{R}^{n \\times n} and the rhs vector is b = \\hat{A}^T\\hat{b} \\in \\mathbb{R}^n. Below you can find Vanilla CG algorithm (on the left) and preconditioned CG algorithm (on the right):\n\n\\begin{aligned}\n& \\mathbf{r}_0 := \\mathbf{b} - \\mathbf{A x}_0 \\\\\n& \\hbox{if } \\mathbf{r}_{0} \\text{ is sufficiently small, then return } \\mathbf{x}_{0} \\text{ as the result}\\\\\n& \\mathbf{d}_0 := \\mathbf{r}_0 \\\\\n& k := 0 \\\\\n& \\text{repeat} \\\\\n& \\qquad \\alpha_k := \\frac{\\mathbf{r}_k^\\mathsf{T} \\mathbf{r}_k}{\\mathbf{d}_k^\\mathsf{T} \\mathbf{A d}_k}  \\\\\n& \\qquad \\mathbf{x}_{k+1} := \\mathbf{x}_k + \\alpha_k \\mathbf{d}_k \\\\\n& \\qquad \\mathbf{r}_{k+1} := \\mathbf{r}_k - \\alpha_k \\mathbf{A d}_k \\\\\n& \\qquad \\hbox{if } \\mathbf{r}_{k+1} \\text{ is sufficiently small, then exit loop} \\\\\n& \\qquad \\beta_k := \\frac{\\mathbf{r}_{k+1}^\\mathsf{T} \\mathbf{r}_{k+1}}{\\mathbf{r}_k^\\mathsf{T} \\mathbf{r}_k} \\\\\n& \\qquad \\mathbf{d}_{k+1} := \\mathbf{r}_{k+1} + \\beta_k \\mathbf{d}_k \\\\\n& \\qquad k := k + 1 \\\\\n& \\text{end repeat} \\\\\n& \\text{return } \\mathbf{x}_{k+1} \\text{ as the result}\n\\end{aligned} \\qquad\n\\begin{aligned}\n& \\mathbf{r}_0 := \\mathbf{b} - \\mathbf{A x}_0 \\\\\n& \\text{if } \\mathbf{r}_0 \\text{ is sufficiently small, then return } \\mathbf{x}_0 \\text{ as the result} \\\\\n& \\mathbf{z}_0 := \\mathbf{M} \\mathbf{r}_0 \\\\\n& \\mathbf{d}_0 := \\mathbf{z}_0 \\\\\n& k := 0 \\\\\n& \\text{repeat} \\\\\n& \\qquad \\alpha_k := \\frac{\\mathbf{r}_k^\\mathsf{T} \\mathbf{z}_k}{\\mathbf{d}_k^\\mathsf{T} \\mathbf{A d}_k} \\\\\n& \\qquad \\mathbf{x}_{k+1} := \\mathbf{x}_k + \\alpha_k \\mathbf{d}_k \\\\\n& \\qquad \\mathbf{r}_{k+1} := \\mathbf{r}_k - \\alpha_k \\mathbf{A d}_k \\\\\n& \\qquad \\text{if } \\mathbf{r}_{k+1} \\text{ is sufficiently small, then exit loop} \\\\\n& \\qquad \\mathbf{z}_{k+1} := \\mathbf{M} \\mathbf{r}_{k+1} \\\\\n& \\qquad \\beta_k := \\frac{\\mathbf{r}_{k+1}^\\mathsf{T} \\mathbf{z}_{k+1}}{\\mathbf{r}_k^\\mathsf{T} \\mathbf{z}_k} \\\\\n& \\qquad \\mathbf{d}_{k+1} := \\mathbf{z}_{k+1} + \\beta_k \\mathbf{d}_k \\\\\n& \\qquad k := k + 1 \\\\\n& \\text{end repeat} \\\\\n& \\text{return } \\mathbf{x}_{k+1} \\text{ as the result}\n\\end{aligned}\n\nHadamard matrix\nGiven m \\in \\{2^i, i = 1, 2, \\ldots\\}, the (unnormalized) Hadamard matrix of order m is defined recursively as\n\nH_2 = \\begin{bmatrix} 1 & 1 \\\\ 1 & -1 \\end{bmatrix}, \\quad \\text{and} \\quad H_m = \\begin{bmatrix} H_{m/2} & H_{m/2} \\\\ H_{m/2} & -H_{m/2} \\end{bmatrix}.\n\nThe associated normalized Hadamard matrix is given by H^{(\\text{norm})}_m = \\frac{1}{\\sqrt{m}} H_m, which evidently satisfies H^{(\\text{norm})T}_m H^{(\\text{norm})}_m = I_{m \\times m}. Moreover, via a recursive algorithm, it is possible to compute matvec H_m x in time O(m \\log m), which is much faster than m^2 for a general matrix.\nTo solve the least squares minimization problem using conjugate gradients, we must solve \\hat{A}^T \\hat{A} x = \\hat{A}^T b. Using a preconditioner M such that M \\approx A^{-1} can give substantial speedup in computing solutions to large problems.\nConsider the following scheme to generate a randomized preconditioner, assuming that m = 2^i for some i:\n\nLet S = \\text{diag}(S_{11}, \\ldots, S_{mm}), where S_{jj} are random \\{-1,+1\\} signs\nLet p \\in \\mathbb{Z}^+ be a small positive integer, say 20 for this problem.\nLet R \\in \\{0, 1\\}^{n+p \\times m} be a row selection matrix, meaning that each row of R has only 1 non-zero entry, chosen uniformly at random. (The location of these non-zero columns is distinct.)\nimport jax.numpy as jnp\nfrom jax import random\n\ndef create_row_selection_matrix_jax(m, n, p, key):\n    # m is the number of columns in the original matrix A\n    # n+p is the number of rows in the row selection matrix R\n    # key is a PRNGKey needed for randomness in JAX\n    inds = random.permutation(key, m)[:n+p]  # Generate a random permutation and select the first n+p indices\n    R = jnp.zeros((n+p, m), dtype=jnp.int32)  # Create a zero matrix of shape (n+p, m)\n    R = R.at[np.arange(n+p), inds].set(1)     # Use JAX's indexed update to set the entries corresponding to inds to 1\n    return R\nDefine \\Phi = R H^{(\\text{norm})}_m S \\in \\mathbb{R}^{n+p \\times m}\n\nWe then define the matrix M via its inverse M^{-1} = \\hat{A}^T \\Phi^T \\Phi \\hat{A} \\in \\mathbb{R}^{n \\times n}.\nQuestions\n\n(2 point) How many FLOPs (floating point operations, i.e.¬†multiplication and additions) are required to compute the matrices M^{-1} and M, respectively, assuming that you can compute the matrix-vector product H_mv in time m \\log m for any vector v \\in \\mathbb{R}^m?\n(2 point) How many FLOPs are required to naively compute \\hat{A}^T \\hat{A}, assuming \\hat{A} is dense (using standard matrix algorithms)?\n(2 point) How many FLOPs are required to compute \\hat{A}^T \\hat{A} v for a vector v \\in \\mathbb{R}^n by first computing u = \\hat{A}v and then computing \\hat{A}^T u?\n(4 poins) Suppose that conjugate gradients runs for k iterations. Using the preconditioned conjugate gradient algorithm with M = (\\hat{A}^T \\Phi^T \\Phi \\hat{A})^{-1}, how many total floating point operations have been performed? How many would be required to directly solve \\hat{A}^T \\hat{A} x = \\hat{A}^T b? How large must k be to make the conjugate gradient method slower?\n(10 points) Implement the conjugate gradient algorithm for solving the positive definite linear system \\hat{A}^T \\hat{A} x = \\hat{A}^T b both with and without the preconditioner M. To generate data for your problem, set m = 2^{12} and n = 400, then generate the matrix A and the vector b. For simplicity in implementation, you may directly pass \\hat{A}^T \\hat{A} and \\hat{A}^T b into your conjugate gradient solver, as we only wish to explore how the methods work.\n\nimport numpy as np\nfrom scipy.sparse import diags\n\nm = 2**12  # 4096\nn = 400\n# Create a linear space of values from 0.001 to 100\nvalues = np.linspace(0.001, 100, n)\n# Generate the matrix A\nA = np.random.randn(m, n) * diags(values).toarray()\nb = np.random.randn(m, 1)\nPlot the norm of the residual r_k = \\hat{A}^T b - \\hat{A}^T \\hat{A} x_k (relative to \\|\\hat{A}^T b\\|_2) as a function of iteration k for each of your conjugate gradient procedures. Additionally, compute and print the condition numbers \\kappa(\\hat{A}^T \\hat{A}) and \\kappa(M^{1/2} \\hat{A}^T \\hat{A} M^{1/2}).\n\n\n\nNewton and quasinewton methods\n\nüò± Newton convergence issue (10 points)\nConsider the following function:\n\nf(x,y) = \\dfrac{x^4}{4} - x^2 + 2x + (y-1)^2\n\nAnd the starting point is x_0 = (0,2)^\\top. How does Newton‚Äôs method behave when started from this point? How can this be explained? How does the gradient descent with fixed step \\alpha = 0.01 and the steepest descent method behave under the same conditions? (It is not necessary to show numerical simulations in this problem).\nHessian-Free Newton method (20 points) In this exercise, we‚Äôll explore the optimization of a binary logistic regression problem using various methods. Don‚Äôt worry about the size of the problem description, first 5 bullets out of 7 could be done pretty quickly. In this problem you should start with this colab notebook\nGiven a dataset with n observations, where each observation consists of a feature vector x_i and an associated binary target variable y_i \\in \\{0,1\\}, the logistic regression model predicts the probability that y_i = 1 given x_i using the logistic function. The loss function to be minimized is the negative log-likelihood of the observed outcomes under this model, summed across all observations. It has a high value when the model outputs differ significantly from the data y.\nThe binary cross-entropy loss function for a single observation (x_i, y_i) is given by: \n\\text{Loss}(w; x_i, y_i) = -\\left[ y_i \\log(p(y_i=1 | x_i; w)) + (1-y_i) \\log(1-p(y_i=1 | x_i; w)) \\right]\n\nHere, p(y=1 | x;w) is defined as: \np(y=1 | x;w) = \\frac{1}{1 + e^{-w^T x}}\n\nTo define the total loss over the dataset, we sum up the individual losses: \nf(w) = -\\sum_{i=1}^n \\left[ y_i \\log(p(y_i=1 | x_i; w)) + (1-y_i) \\log(1-p(y_i=1 | x_i; w)) \\right]\n\nTherefore, the optimization problem in logistic regression is: \n\\min_w f(w) = \\min_w -\\sum_{i=1}^n \\left[ y_i \\log\\left(p\\left(y_i=1 | x_i; w\\right)\\right) + \\left(1-y_i\\right) \\log\\left(1-p(y_i=1 | x_i; w)\\right) \\right]\n\nThis is a convex optimization problem and can be solved using gradient-based methods such as gradient descent, Newton‚Äôs method, or more sophisticated optimization algorithms often available in machine learning libraries. However, it is the problem is often together with l_2 regularization:\n\n\\min_w f(w) = \\min_w -\\sum_{i=1}^n \\left[ y_i \\log\\left(p\\left(y_i=1 | x_i; w\\right)\\right) + \\left(1-y_i\\right) \\log\\left(1-p(y_i=1 | x_i; w)\\right) \\right] + \\frac{\\mu}{2} \\|w\\|_2^2\n\n\n(2 points) Firstly, we address the optimization with Gradient Descent (GD) in a strongly convex setting, with \\mu = 1. Use a constant learning rate \\alpha. Run the gradient descent algorithm. Report the highest learning rate that ensures convergence of the algorithm. Plot the convergence graph in terms of both domain (parameter values) and function value (loss). Describe the type of convergence observed.\nparams = {\n    \"mu\": 1,\n    \"m\": 1000,\n    \"n\": 100,\n    \"methods\": [\n        {\n            \"method\": \"GD\",\n            \"learning_rate\": 3e-2,\n            \"iterations\": 550,\n        },\n    ]\n}\n\nresults, params = run_experiments(params)\n(2 points) Run Newton‚Äôs method under the same conditions, using the second derivatives to guide the optimization. Describe and analyze the convergence properties observed.\nparams = {\n    \"mu\": 1,\n    \"m\": 1000,\n    \"n\": 100,\n    \"methods\": [\n        {\n            \"method\": \"GD\",\n            \"learning_rate\": 3e-2,\n            \"iterations\": 550,\n        },\n        {\n            \"method\": \"Newton\",\n            \"iterations\": 20,\n        },\n    ]\n}\n\nresults, params = run_experiments(params)\n(2 points) In cases where Newton‚Äôs method may converge too rapidly or overshoot, a damped version can be more stable. Run the damped Newton method. Adjust the damping factor as a learning rate. Report the highest learning rate ensuring stability and convergence. Plot the convergence graph.\nparams = {\n    \"mu\": 1,\n    \"m\": 1000,\n    \"n\": 100,\n    \"methods\": [\n        {\n            \"method\": \"GD\",\n            \"learning_rate\": 3e-2,\n            \"iterations\": 550,\n        },\n        {\n            \"method\": \"Newton\",\n            \"iterations\": 20,\n        },\n        {\n            \"method\": \"Newton\",\n            \"learning_rate\": 5e-1,\n            \"iterations\": 50,\n        },\n    ]\n}\n\nresults, params = run_experiments(params)\n(2 points) Now turn off the regularization by setting \\mu=0. Try to find the largest learning rate, which ensures convergence of the Gradient Descent. Use a constant learning rate \\alpha. Run the gradient descent algorithm. Report the highest learning rate that ensures convergence of the algorithm. Plot the convergence graph in terms of both domain (parameter values) and function value (loss). Describe the type of convergence observed. How can you describe an idea to run this method for the problem to reach tight primal gap f(x_k) - f^* \\approx 10^{-2} or 10^{-3}, 10^{-4}?\nparams = {\n    \"mu\": 0,\n    \"m\": 1000,\n    \"n\": 100,\n    \"methods\": [\n        {\n            \"method\": \"GD\",\n            \"learning_rate\": 3e-2,\n            \"iterations\": 200,\n        },\n        {\n            \"method\": \"GD\",\n            \"learning_rate\": 7e-2,\n            \"iterations\": 200,\n        },\n    ]\n}\n\nresults, params = run_experiments(params)\n(2 points) What can you say about Newton‚Äôs method convergence in the same setting \\mu=0? Try several learning rates smaller, than 1 for the damped Newton method. Does it work? Write your conclusions about the second-order method convergence for a binary logistic regression problem.\n(5 points) Now switch back to the strongly convex setting \\mu=1. To avoid directly computing the Hessian matrix in Newton‚Äôs method, use the Conjugate Gradient (CG) method to solve the linear system in the Newton step. Develop the newton_method_cg function, which computes the Newton step using CG to solve the system \\nabla^2 f(x_k) d_k = - \\nabla f(x_k), \\; x_{k+1} = x_k + \\alpha d_k defined by the Hessian. You have to use jax.scipy.sparse.linalg.cg function here. So, firstly compute the hessian as it was done in the code, then put it into this linear solver. Compare its performance in terms of computational efficiency and convergence rate to the standard Newton method.\n(5 points) Finally, implement a Hessian-free version of Newton‚Äôs method (HFN) which utilizes Hessian-vector products derived via automatic differentiation. Note, that jax.scipy.sparse.linalg.cg function can take the matvec function, which directly produces the multiplication of any input vector x. Implement the HFN method without explicitly forming or storing the Hessian matrix in function newton_method_hfn. Use autograd to compute Hessian-vector products as it is described here. Compare this method‚Äôs time complexity and memory requirements against previous implementations.\n\n\n\n\nConditional gradient methods\n\nProjection onto the Birkhoff Polytope using Frank-Wolfe [20 points]\nIn a recent book authors presented the following comparison table with complexities of linear minimizations and projections on some convex sets up to an additive error \\epsilon in the Euclidean norm. When \\epsilon is missing, there is no additive error. The \\tilde{\\mathcal{O}} hides polylogarithmic factors in the dimensions and polynomial factors in constants related to thedistancetothe optimum. For the nuclear norm ball, i.e., the spectrahedron, \\nu denotes the number of non-zero entries and \\sigma_1 denotes the top singular value of the projected matrix.\n\n\n\n\n\n\n\n\nSet\nLinear minimization\nProjection\n\n\n\n\nn-dimensional \\ell_p-ball, p \\neq 1,2,\\infty\n\\mathcal{O}(n)\n\\tilde{\\mathcal{O}}\\!\\bigl(\\tfrac{n}{\\epsilon^2}\\bigr)\n\n\nNuclear norm ball of n\\times m matrices\n\\mathcal{O}\\!\\Bigl(\\nu\\,\\ln(m + n)\\,\\tfrac{\\sqrt{\\sigma_1}}{\\sqrt{\\epsilon}}\\Bigr)\n\\mathcal{O}\\!\\bigl(m\\,n\\,\\min\\{m,n\\}\\bigr)\n\n\nFlow polytope on a graph with m vertices and n edges (capacity bound on edges)\n\\mathcal{O}\\!\\Bigl((n \\log m)\\bigl(n + m\\,\\log m\\bigr)\\Bigr)\n\\tilde{\\mathcal{O}}\\!\\bigl(\\tfrac{n}{\\epsilon^2}\\bigr)\\ \\text{or}\\ \\mathcal{O}(n^4\\,\\log n)\n\n\nBirkhoff polytope (n \\times n doubly stochastic matrices)\n\\mathcal{O}(n^3)\n\\tilde{\\mathcal{O}}\\!\\bigl(\\tfrac{n^2}{\\epsilon^2}\\bigr)\n\n\n\nThe Birkhoff polytope, denoted as B_n, is the set of n \\times n doubly stochastic matrices: \nB_n = \\{ X \\in \\mathbb{R}^{n \\times n} \\mid X_{ij} \\ge 0 \\;\\forall i,j, \\quad X \\mathbf{1} = \\mathbf{1}, \\quad X^T \\mathbf{1} = \\mathbf{1} \\}\n where \\mathbf{1} is the vector of all ones. This set is convex and compact. Its extreme points are the permutation matrices.\nGiven an arbitrary matrix Y \\in \\mathbb{R}^{n \\times n}, we want to find its projection onto B_n, which is the solution to the optimization problem: \n\\min_{X \\in B_n} f(X) = \\frac{1}{2} \\| X - Y \\|_F^2\n where \\| \\cdot \\|_F is the Frobenius norm.\nWe will use the Frank-Wolfe (Conditional Gradient) algorithm to solve this problem. Recall the steps of the Frank-Wolfe algorithm:\n\nInitialize X_0 \\in B_n.\nFor k = 0, 1, 2, \\ldots:\n\nCompute the gradient \\nabla f(X_k).\nSolve the Linear Minimization Oracle (LMO): S_k = \\arg\\min_{S \\in B_n} \\langle \\nabla f(X_k), S \\rangle.\nDetermine the step size \\gamma_k \\in [0, 1].\nUpdate X_{k+1} = (1-\\gamma_k) X_k + \\gamma_k S_k.\n\n\nTasks:\n\n[5 points] Explicitly write down the gradient \\nabla f(X_k). Explain how to solve the LMO step \\min_{S \\in B_n} \\langle \\nabla f(X_k), S \\rangle. What kind of matrix is the solution S_k? Hint: Consider the connection to the linear assignment problem (Hungarian algorithm).\n[10 points] Implement the Frank-Wolfe algorithm in Python to solve the projection problem. Use scipy.optimize.linear_sum_assignment to solve the LMO. For the step size, you can use the optimal closed-form solution for projection: \\gamma_k = \\frac{\\langle X_k - Y, X_k - S_k \\rangle}{\\| X_k - S_k \\|_F^2}, clipped to [0, 1].\nimport numpy as np\nfrom scipy.optimize import linear_sum_assignment\nimport matplotlib.pyplot as plt\n\ndef project_to_birkhoff_frank_wolfe(Y, max_iter=100, tol=1e-6):\n    \"\"\"\n    Projects matrix Y onto the Birkhoff polytope using the Frank-Wolfe algorithm.\n\n    Args:\n        Y (np.ndarray): The matrix to project.\n        max_iter (int): Maximum number of iterations.\n        tol (float): Tolerance for convergence (change in objective value).\n\n    Returns:\n        np.ndarray: The projection of Y onto the Birkhoff polytope.\n        list: History of objective function values.\n    \"\"\"\n    n = Y.shape[0]\n    assert Y.shape[0] == Y.shape[1], \"Input matrix must be square\"\n\n    # Initialize with a feasible point (e.g., uniform matrix)\n    Xk = np.ones((n, n)) / n\n\n    objective_history = []\n\n    for k in range(max_iter):\n        # Objective function value\n        obj_val = 0.5 * np.linalg.norm(Xk - Y, 'fro')**2\n        objective_history.append(obj_val)\n\n        if k &gt; 0 and abs(objective_history[-1] - objective_history[-2]) &lt; tol:\n            print(f\"Converged after {k} iterations.\")\n            break\n\n        # 1. Compute gradient\n        grad_fk = ... # YOUR CODE HERE \n\n        # 2. Solve the LMO: S_k = argmin_{S in Birkhoff} &lt;grad_fk, S&gt;\n        # Use linear_sum_assignment on the cost matrix grad_fk\n        row_ind, col_ind = ... # YOUR CODE HERE using linear_sum_assignment\n        Sk = np.zeros((n, n))\n        # Construct permutation matrix Sk based on row_ind, col_ind\n        ... # YOUR CODE HERE \n\n        # 3. Compute step size gamma_k \n        # Optimal step size for projection, clipped to [0, 1]\n        delta_k = Xk - Sk\n        denom = np.linalg.norm(delta_k, 'fro')**2\n        if denom &lt; 1e-12: # Avoid division by zero if Xk is already the vertex Sk\n            gamma_k = 0.0\n        else:\n            gamma_k = ... # YOUR CODE HERE for optimal step size\n            gamma_k = np.clip(gamma_k, 0.0, 1.0) \n\n        # 4. Update\n        Xk = ... # YOUR CODE HERE \n\n    else: # If loop finishes without breaking\n         print(f\"Reached max iterations ({max_iter}).\")\n\n    return Xk, objective_history\n[5 points] Test your implementation with n=5 and a randomly generated matrix Y = \\text{np.random.rand}(5, 5). Run the algorithm for 200 iterations. Plot the objective function value f(X_k) versus the iteration number k. Verify numerically that the final matrix X_{200} approximately satisfies the conditions for being in B_5 (non-negative entries, row sums equal to 1, column sums equal to 1).\n\n[Minimizing a Quadratic over the Simplex] [20 points] Consider the problem of minimizing a quadratic function over the standard probability simplex: \n\\min_{x \\in \\Delta_n} f(x) = \\frac{1}{2} x^T Q x + c^T x\n where \\Delta_n = \\{x \\in \\mathbb{R}^n \\mid \\sum_{i=1}^n x_i = 1, x_i \\ge 0\\} is the standard simplex in \\mathbb{R}^n, Q \\in \\mathbb{S}^n_{++} is a positive definite matrix, and c \\in \\mathbb{R}^n.\n\n[5 points] Generate the problem data: Choose a dimension n (e.g., n=20). Create a random positive definite matrix Q with a given spectrum [\\mu; L] and a random vector x^* \\in \\Delta_n, so c = -Q x^* (e.g., with standard normal entries).\n\nSpecify and consider 2 different starting points (you will use them for another algorithm as well)\nCalculate f(x^*) and f(x_0), you will have to track |f(x_k) - f(x^*)| for both algorithms\n\n[7 points] Implement the Frank-Wolfe (Conditional Gradient) algorithm to solve this problem. Do not forget to start from a feasible point.\n[8 points] Implement the Projected Gradient Descent algorithm.\n\nUse the same starting points x_0.\nJustify learning rate selection.\nWe do not have an explicit formula for Euclidean projection onto the standard simplex. You will need an algorithm for projection onto the standard simplex (e.g., see Duchi et al., 2008 or use available implementations).\n\nPlot the objective function value f(x_k) versus the iteration number k for both Frank-Wolfe and Projected Gradient Descent on the same graph. Compare their convergence behavior. Discuss which method appears to converge faster in terms of iterations for this problem.\n\n\n\n\nSubgradient method\n\nFinding a point in the intersection of convex sets. [30 points] Let A \\in \\mathbb{R}^{n \\times n} be some non-degenerate matrix and let \\Sigma be an n \\times n diagonal matrix with diagonal entries \\sigma_1,...,\\sigma_n &gt; 0, and y a given vector in \\mathbb{R}^n. Consider the compact convex sets U = \\{x \\in \\mathbb{R}^n \\mid \\|A(x-y)\\|_2 \\leq 1\\} and V = \\{x \\in \\mathbb{R}^n \\mid \\|\\Sigma x\\|_\\infty \\leq 1\\}.\n\n[10 points] Minimize maximum distance from the current point to the convex sets.\n\n  \\min_{x\\in\\mathbb{R}^n} f(x) =  \\min_{x\\in\\mathbb{R}^n} \\max\\{\\mathbf{dist}(x, U), \\mathbf{dist}(x, V)\\}\n  \npropose an algorithm to find a point x \\in U \\cap V. You can assume that U \\cap V is not empty. Your algorithm must be specific and provably converging (although you do not need to prove it and you can simply refer to the lecture slides).\n[15 points] Implement your algorithm with the following data: n = 2, y = (3, 2), \\sigma_1 = 0.5, \\sigma_2 = 1,\n\n  A = \\begin{bmatrix}\n  1 & 0 \\\\\n  -1 & 1\n  \\end{bmatrix},\n  \nPlot the objective value of your optimization problem versus the number of iterations. Choose the following initial points x_0 = [(2, -1), (0, 0), (1, 2)].\n[5 points] Discussion: compare the three curves. Describe the properties of this optimization problem.\n\nIs it convex/strongly convex?\nIs it smooth?\nDo we have a unique solution here?\nWhich start converges fastest / slowest and why? Relate your observations to the initial distance to U \\cap V and to the contact angle between the two sets at the solution.\n\n\n\n\n\nIllustration of the problem\n\n\nSubgradient methods for Lasso. (10 points)\nConsider the optimization problem\n\n\\min_{x \\in \\mathbb{R}^n} f(x) := \\frac12 \\|Ax - b\\|^2 + \\lambda \\|x\\|_1,\n\nwith variables x \\in \\mathbb{R}^n and problem data A \\in \\mathbb{R}^{m \\times n}, b \\in \\mathbb{R}^m and \\lambda &gt; 0. This model is known as Lasso, or Least Squares with l_1 regularization, which encourages sparsity in the solution via the non-smooth penalty \\|x\\|_1 := \\sum_{j=1}^n |x_j|. In this problem, we will explore various subgradient methods for fitting this model.\n\nDerive the subdifferential \\partial f(x) of the objective.\nFind the update rule of the subgradient method and state the computational complexity of applying one update using big O notation in terms of the dimensions.\nLet n = 1000, m = 200 and \\lambda = 0.01. Generate a random matrix A \\in \\mathbb{R}^{m \\times n} with independent Gaussian entries with mean 0 and variance 1/m, and a fixed vector x^* = {\\underbrace{[1, \\ldots, 1}_{\\text{k times}}, \\underbrace{0, \\ldots, 0]}_{\\text{n-k times}}}^T \\in \\mathbb{R}^n. Let k = 5 and then set b = Ax^*. Implement the subgradient method to minimize f(x), initialized at the all-zeros vector. Try different step size rules, including:\n\nconstant step size \\alpha_k = \\alpha\nconstant step length \\alpha_k = \\frac{\\gamma}{\\|g_k\\|_2} (so \\|x^{k+1} - x^k\\|_2 = \\gamma)\nInverse square root \\frac{1}{\\sqrt{k}}\nInverse \\frac1k\nPolyak‚Äôs step length with estimated objective value:\n\n  \\alpha_k = \\frac{f(x_k) - f_k^{\\text{best}} + \\gamma_k}{\\|g_k\\|_2^2}, \\quad \\text{ with} \\sum_{k=1}^\\infty \\gamma_k = \\infty, \\quad \\sum_{k=1}^\\infty \\gamma_k^2 &lt; \\infty\n  \nFor example, one can use \\gamma_k = \\frac{10}{10 + k}. Here f_k^{\\text{best}} - \\gamma_k serves as estimate of f^*. It is better to take \\gamma_k in the same scale as the objective value. One can show, that f_k^{\\text{best}} \\to f^*.\n\nPlot objective value versus iteration curves of different step size rules on the same figure.\nRepeat previous part using a heavy ball term, \\beta_k(x^k - x^{k-1}), added to the subgradient. Try different step size rules as in the previous part and tune the heavy ball parameter \\beta_k = \\beta for faster convergence.\n\n\n\n\nProximal gradient method\n\n[20 points] Proximal Method for Sparse Softmax Regression Softmax regression, also known as multinomial logistic regression, is a generalization of logistic regression to multiple classes. It is used to model categorical outcome variables where each category is mutually exclusive. The softmax function transforms any input vector to the probability-like vector as follows:\n\nP(y = j | x; W) = \\frac{e^{W_j^T x}}{\\sum\\limits_{i=1}^{c} e^{W_i^T x}}\n\n\n\n\nScheme of softmax regression\n\n\nwhere x is the input vector, W is the weight matrix, c is the number of classes, and P(y = j | x; W) is the probability that the input x belongs to class j.\nThe optimization problem for softmax regression is to minimize the negative log-likelihood:\n\n\\min_{W \\in \\mathbb{R}^{c \\times d}} -\\sum_{i=1}^{N} \\log P(y_i | x_i; W) + \\lambda \\| W \\|_1\n\nwhere N is the number of training examples, \\lambda is the regularization parameter, and \\| W \\|_1 is the L1 norm of the weight matrix, which promotes sparsity in the solution. I suggest you to vectorize matrix and add 1-vector norm.\nWe will solve the sparse softmax regression problem using the subgradient method and the proximal gradient method, both incorporating L1 regularization. The proximal gradient method is particularly useful for optimization problems involving non-smooth regularizers like the L1 norm. We will use 3 class classification problem of Predicting Students‚Äô Dropout and Academic Success. In this problem you should start with this colab notebook\n\n[4 points] Write down exact formulation of subgradient method and proximal gradient method here (you can not use any optimization problems in this formulation).\n[6 points] Choose \\lambda = 0. Solve the softmax regression problem using subgradient method and proximal gradient descent. Find the highest learning (individually), acceptable for both methods to converge. Report convergence curves and report final sparsity of both methods. Draw you conclusions.\n[10 points] Solve non-smooth problem and fill the following table. For each value of \\lambda provide convergence curves.\n\nReport the number of iterations needed to reach specified primal gaps for each method. Present the results in the following markdown table:\n\n\n\n\n\n\n\n\n\n\n\n\n\nMethod\nLearning Rate (\\eta)\nTolerance (\\epsilon)\nNumber of Iterations\nComment(if any)\nFinal Sparsity of the solution\n\\lambda\nFinal test accuracy\n\n\n\n\nsubgradient method\n\n10^{-1}\n\n\n\n1e-2\n\n\n\nsubgradient method\n\n10^{-2}\n\n\n\n1e-2\n\n\n\nsubgradient method\n\n10^{-3}\n\n\n\n1e-2\n\n\n\nsubgradient method\n\n10^{-4}\n\n\n\n1e-2\n\n\n\nsubgradient method\n\n10^{-5}\n\n\n\n1e-2\n\n\n\nProximal Gradient Descent\n\n10^{-1}\n\n\n\n1e-2\n\n\n\nProximal Gradient Descent\n\n10^{-2}\n\n\n\n1e-2\n\n\n\nProximal Gradient Descent\n\n10^{-3}\n\n\n\n1e-2\n\n\n\nProximal Gradient Descent\n\n10^{-4}\n\n\n\n1e-2\n\n\n\nProximal Gradient Descent\n\n10^{-5}\n\n\n\n1e-2\n\n\n\nsubgradient method\n\n10^{-2}\n\n\n\n1e-3\n\n\n\nProximal Gradient Descent\n\n10^{-2}\n\n\n\n1e-3\n\n\n\nsubgradient method\n\n10^{-2}\n\n\n\n1e-1\n\n\n\nProximal Gradient Descent\n\n10^{-2}\n\n\n\n1e-1\n\n\n\nsubgradient method\n\n10^{-2}\n\n\n\n1\n\n\n\nProximal Gradient Descent\n\n10^{-2}\n\n\n\n1\n\n\n\n\n\n\n\nStochastic gradient methods\n\nVariance reduction for stochastic gradient methods. [20 points]\n[5 points]Open colab notebook. Implement SAG and SVRG method. Consider Linear least squares problem with the following setup\nparams = {\n    \"mu\": 0,\n    \"m\": 50,\n    \"n\": 100,\n    \"methods\": [\n        {\n            \"method\": \"SGD\",\n            \"learning_rate\": 1e-2,\n            \"batch_size\": 2,\n            \"iterations\": 1000,\n        },\n        {\n            \"method\": \"SGD\",\n            \"learning_rate\": 1e-2,\n            \"batch_size\": 50,\n            \"iterations\": 1000,\n        },\n        {\n            \"method\": \"SAG\",\n            \"learning_rate\": 1e-2,\n            \"batch_size\": 2,\n            \"iterations\": 1000,\n        },\n        {\n            \"method\": \"SVRG\",\n            \"learning_rate\": 1e-2,\n            \"epoch_length\": 2,\n            \"batch_size\": 2,\n            \"iterations\": 1000,\n        },\n    ]\n}\n\nresults = run_experiments(params)\n[5 points] Then, consider strongly convex case with:\nparams = {\n    \"mu\": 1e-1,\n    \"m\": 50,\n    \"n\": 100,\n    \"methods\": [\n        {\n            \"method\": \"SGD\",\n            \"learning_rate\": 1e-2,\n            \"batch_size\": 2,\n            \"iterations\": 2000,\n        },\n        {\n            \"method\": \"SGD\",\n            \"learning_rate\": 1e-2,\n            \"batch_size\": 50,\n            \"iterations\": 2000,\n        },\n        {\n            \"method\": \"SAG\",\n            \"learning_rate\": 1e-2,\n            \"batch_size\": 2,\n            \"iterations\": 2000,\n        },\n        {\n            \"method\": \"SVRG\",\n            \"learning_rate\": 1e-2,\n            \"epoch_length\": 2,\n            \"batch_size\": 2,\n            \"iterations\": 2000,\n        },\n    ]\n}\n[5 points] And for the convex binary logistic regression:\nparams = {\n    \"mu\": 0,\n    \"m\": 100,\n    \"n\": 200,\n    \"methods\": [\n        {\n            \"method\": \"SGD\",\n            \"learning_rate\": 1e-2,\n            \"batch_size\": 2,\n            \"iterations\": 2000,\n        },\n        {\n            \"method\": \"SAG\",\n            \"learning_rate\": 1e-2,\n            \"batch_size\": 2,\n            \"iterations\": 2000,\n        },\n        {\n            \"method\": \"SVRG\",\n            \"learning_rate\": 1e-2,\n            \"epoch_length\": 3,\n            \"batch_size\": 2,\n            \"iterations\": 2000,\n        },\n        {\n            \"method\": \"SGD\",\n            \"learning_rate\": 1e-2,\n            \"batch_size\": 100,\n            \"iterations\": 2000,\n        },\n    ]\n}\n[5 points] and strongly convex case\nparams = {\n    \"mu\": 1e-1,\n    \"m\": 100,\n    \"n\": 200,\n    \"methods\": [\n        {\n            \"method\": \"SGD\",\n            \"learning_rate\": 2e-2,\n            \"batch_size\": 2,\n            \"iterations\": 3000,\n        },\n        {\n            \"method\": \"SAG\",\n            \"learning_rate\": 2e-2,\n            \"batch_size\": 2,\n            \"iterations\": 3000,\n        },\n        {\n            \"method\": \"SVRG\",\n            \"learning_rate\": 2e-2,\n            \"epoch_length\": 3,\n            \"batch_size\": 2,\n            \"iterations\": 3000,\n        },\n        {\n            \"method\": \"SGD\",\n            \"learning_rate\": 2e-2,\n            \"batch_size\": 100,\n            \"iterations\": 3000,\n        },\n    ]\n}\nDescribe the obtained convergence and compare methods.\n\n\n\n\n\n\nNeural network training\n\nAnomaly detection with neural network. [30 points]\nIn this problem we will try to detect anomalies in time series with neural network.\n[Plotly Filter Error: Could not read file: anomaly_detection.html. Error: anomaly_detection.html: No such file or directory]\nWe will train the model to reconstruct normal data and when the reconstruction error for the actual data on trained model is high, we report an anomaly. Start with this notebook colab notebook. The default solution is adam and after training it can detect 4 out of 5 anomalies. Train and compare several methods on the same problem. For each method try to find hyperparameters, which ensures at least 3 out of 5 anomalies detection. Present learning curves and anomaly predictions for each method.\n\nSGD with momentum [5 points] from optax\nAdadelta [5 points] from optax\nBFGS [10 points] implemented manually\nMuon optimizer [10 points] implemented manually\n\n\n\n\nBig models\n\nFit the largest model you can on a single GPU. [15 points]\nIn this assignment, you will train a language model (LM) using the TinyStories dataset, focusing on optimizing model performance within the constraints of Google Colab‚Äôs hardware. For the sake of speed, we will do it on the part of the dataset.\nOnce upon a time, there was a little car named Beep. Beep loved to go fast and play in the sun. \nBeep was a healthy car because he always had good fuel....\nYour objective is to maximize the size of the model without exceeding the available computational resources (~ 16GB VRAM). You could start with the Hugging Face Transformers library and experiment with various memory optimization techniques, such as (but not limited to):\n\nDifferent batch size\nDifferent optimizer\nGradient accumulation\nActivation checkpointing\nCPU offloading\n8bit optimizers\n\nYou have a baseline of training gpt-2 model prepared at the following colab notebook. You can easily switch it to opt-350m, opt-1.3b, gpt2 etc. You can find a great beginner-level guide on the topic here.\nA long time ago in a galaxy far far away... a little girl named Lily was playing in the garden. She was so excited! She wanted to explore the garden and see what was around her.\nSuddenly, she heard a loud noise. Lily looked up and saw a big, hairy creature. Lily was so excited! She ran to the creature and grabbed it by the arm. The creature was so big and hairy that Lily couldn't help but laugh. \n\nYou have to fill this table with your description/observations.\n\n\n\n\n\n\n\n\n\n\n\n\n\nSetup\n# of parameters\nGPU peak memory, MB\nFinal eval loss\nBatch Size\nTime to run 5 epochs, s\nGeneration example\nComment\n\n\n\n\nBaseline (OPT-125M)\n125 M\n9044\n1.928\n8\n442.34\nA long time ago in a galaxy far far away... there was a little girl named Lily. She was three years old and loved to explore. One day, she decided to go for a walk in the park. Lily was so excited to go for a walk. She asked her mom, \"What do you want to do?\" Her mom smiled and said, \"I want to explore the galaxy.\" Lily was so excited to explore the galaxy.\n\n\n\nBaseline (GPT2-S)\n124 M\n13016\n2.001\n8\n487.75\nA long time ago in a galaxy far far away... a little girl named Lily was playing in the garden. She was so excited! She wanted to explore the garden and see what was around her. Suddenly, she heard a loud noise. Lily looked up and saw a big, hairy creature. Lily was so excited! She ran to the creature and grabbed it by the arm. The creature was so big and hairy that Lily couldn't help but laugh.\nThe generation seems more interesting, despite the fact, that eval loss is higher.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFor each unique trick for memory optimization, you will get 3 points (maximum 15 points). A combination of tricks is not counted as a unique trick, but will, probably, be necessary to train big models. The maximum grade is bounded with the size of the trained model:\n\nIf the model size you train is &lt;= 125M - you can get a maximum of 6 points.\nIf the model size you train is 126M &lt;= 350M - you can get a maximum of 8 points.\nIf the model size you train is 350M &lt;= 1B - you can get a maximum of 12 points.\nIf you fit 1B model or more - you can get a maximum 15 points.\n\n\n\n\nADMM (Dual methods)\n\nLow‚ÄëRank Matrix Completion via ADMM [25 points]\nBackground. In many applications such as recommender systems, computer vision and system identification, the data matrix is approximately low‚Äërank but only a subset of its entries are observed. Recovering the missing entries can be posed as a convex program that combines a data‚Äëfitting term with the nuclear norm, a convex surrogate for rank.\nWe are given a partially observed matrix M \\in \\mathbb{R}^{m\\times n} and the index set of observed entries \\Omega \\subseteq \\{1,\\dots,m\\} \\times \\{1,\\dots,n\\}. Define the sampling operator P_\\Omega : \\mathbb{R}^{m\\times n}\\to\\mathbb{R}^{m\\times n} by (P_\\Omega(X))_{ij}= X_{ij} if (i,j)\\in\\Omega and 0 otherwise.\nWe consider the optimization problem \n\\min_{X\\in\\mathbb{R}^{m\\times n}}\\;\\frac12\\|P_\\Omega(X-M)\\|_F^2\\; + \\;\\lambda\\|X\\|_*,\n where \\|X\\|_* = \\sum_k \\sigma_k(X) is the nuclear norm.\n\n(a) [10 points] Derive a two‚Äëblock ADMM algorithm.\nIntroduce an auxiliary variable Z and rewrite the problem in the form\n\n\\min_{X,Z}\\; \\frac12\\|P_\\Omega(Z-M)\\|_F^2 + \\lambda\\|X\\|_* \\quad\\text{s.t. } X-Z = 0.\n Derive explicit closed‚Äëform expressions for each ADMM update:\n\nX‚Äëupdate: singular‚Äëvalue soft‚Äëthresholding (SVT);\nZ‚Äëupdate: projection onto the observed entries (keep M on \\Omega, average with X elsewhere);\ndual‚Äëvariable update.\n\nState a practical stopping rule based on the primal and dual residuals.\n(b) [10 points] Implement the algorithm on synthetic data.\nUse the following set‚Äëup (in Python):\nimport numpy as np\nnp.random.seed(0)\nm, n, r = 50, 40, 3\nU = np.random.randn(m, r)\nV = np.random.randn(n, r)\nM_star = U @ V.T                      # ground‚Äëtruth low‚Äërank matrix\nmask = np.random.rand(m, n) &lt; 0.3     # 30 % observations\nnoise = 0.01 * np.random.randn(m, n)\nM = mask * (M_star + noise)           # observed matrix (zeros elsewhere)\nlambda_ = 1 / np.sqrt(max(m, n))\n\nImplement the ADMM algorithm derived in part (a).\nRun it from X^0 = 0 for three penalty parameters \\rho \\in \\{0.1, 1, 10\\}.\nFor each \\rho:\n\nplot (i) the objective value and (ii) the relative reconstruction error \\frac{\\|X^k - M_\\star\\|_F}{\\|M_\\star\\|_F} versus iteration number;\nreport the number of iterations required until \\max(\\|r_{\\mathrm p}^k\\|_F,\\|r_{\\mathrm d}^k\\|_F) \\le 10^{-3}.\n\n\n(c) [5 points] Discussion.\nCompare the convergence behaviour across the three values of \\rho. How does \\rho influence the rate at which the primal and dual residuals decrease? Comment on\n\nthe rank of the iterates (after SVT);\nthe trade‚Äëoff between data‚Äëfit and nuclear‚Äënorm penalty as \\lambda varies;\nthe quality of the reconstruction once the stopping criterion is met.\n\nRelate your observations to the theory of ADMM and to the sensitivity of singular‚Äëvalue thresholding to the choice of \\rho.\n\n\n\n\nBonus: Continuous time methods\n\nSGD as a splitting scheme and the importance of batches order [30 points]\nBackground: (to be honest you can do the task without reading it)\nThe standard Gradient Descent (GD) method for minimizing f(x) = \\frac{1}{n} \\sum_{i=1}^n f_i(x) can be viewed as an Euler discretization of the gradient flow Ordinary Differential Equation (ODE): \n\\frac{d x}{d t} = -\\nabla f(x) = -\\frac{1}{n} \\sum_{i=1}^n \\nabla f_i(x)\n Stochastic Gradient Descent (SGD), particularly with cycling through mini-batches without replacement, can be interpreted as a splitting scheme applied to this ODE. In a first-order splitting scheme for \\frac{dx}{dt} = A x = \\sum_{i=1}^m A_i x, we approximate the solution x(h) by sequentially applying the flows corresponding to each A_i: x(h) \\approx e^{A_{\\sigma(m)} h} \\ldots e^{A_{\\sigma(1)} h} x_0 for some permutation \\sigma.\nIn the paper authors show that for the linear least squares problem f(x) = \\frac{1}{2n}\\|X x - y\\|^2, where X is split into m row blocks X_i, the corresponding ODE involves matrices A_i = -\\frac{1}{n} X_i^T X_i. If X_i^T = Q_i R_i is the QR decomposition (Q_i has orthonormal columns), let \\Pi_i = I - Q_i Q_i^* be the projector onto the null space of X_i. The paper presents the following result for the asymptotic global error of the splitting scheme:\nTheorem: Let A_i = -\\frac{1}{n} X_i^T X_i for i=1,\\dots,m. Assume each A_i is negative semidefinite and does not have full rank, but their sum A = \\sum A_i does have full rank. Then, for any permutation \\sigma of \\{1, \\dots, m\\}: \n\\lim_{t \\to \\infty}\\| e^{A_{\\sigma(m)}t} \\cdots e^{A_{\\sigma(1)}t} - e^{At}\\| = \\left\\|\\prod_{i=1}^m \\Pi_{\\sigma(i)}\\right\\|\n\nThis error bound depends on the product of projectors \\Pi_i and thus on the order specified by the permutation \\sigma. Since one epoch of SGD corresponds to applying the Euler discretization of each local problem \\frac{dx}{dt} = A_i x sequentially, this suggests that the order in which batches are processed in SGD might affect convergence, especially over many epochs.\nTasks:\n\nInvestigating the Bound Distribution [5 points]\n\nConsider a simple linear least squares problem. \n\\frac{1}{2n}\\|X \\theta - y\\|^2 \\to \\min_{\\theta \\in \\mathbb{R}^{d}}, X \\in \\mathbb{R}^{n \\times d}, y \\in \\mathbb{R}^n\n For example, generate a random matrix X \\in \\mathbb{R}^{80 \\times 20} and a random vector y \\in \\mathbb{R}^{80}.\nSplit X into m=8 batches (row blocks) sequentially X_1, \\ldots, X_8, where each X_i \\in \\mathbb{R}^{10 \\times 20}.\nFor each batch X_i \\in \\mathbb{R}^{10 \\times 20}, you have to compute the projector matrix \\Pi_i = I - Q_i Q_i^* \\in \\mathbb{R}^{20 \\times 20}, where X_i^T = Q_i R_i is the (thin) QR decomposition of X_i^T \\in \\mathbb{R}^{20 \\times 10} (Q_i \\in \\mathbb{R}^{20 \\times r_i}, R_i \\in \\mathbb{R}^{r_i \\times 10}, with r_i = \\text{rank}(X_i) \\le 10).\nCalculate the error bound norm E(\\sigma) = \\|\\prod_{j=1}^m \\Pi_{\\sigma(j)}\\|_2 (where the product is a 20 \\times 20 matrix) for all m! = 8! = 40320 possible permutations \\sigma. Note, that this quantity is a scalar and depends on the order of batches in multiplication (permutation \\sigma), i.e.¬†\\|\\Pi_1 \\Pi_2\\| \\neq \\|\\Pi_2 \\Pi_1\\|.\nPlot a histogram of the distribution of these scalar E(\\sigma) values. Does the order seem to matter significantly in this random case?\n\nMaximizing Order Dependence with adversarial dataset construction [20 points]\n\nModify the structure of the matrix X (or the way it is split into X_i, but you cannot change the number of batches and their size) from Task 1 to create a scenario where the distribution of the error bounds E(\\sigma) has a significantly larger variance (to be precise, the ratio of the maximum to minimum values for different permutations should be maximized). Hint: Think about how the projectors \\Pi_i interact. How could you make the product \\Pi_{\\sigma(m)} \\cdots \\Pi_{\\sigma(1)} very different for different orders \\sigma? Consider cases where the null spaces have specific overlaps or orthogonality properties.\nExplain your reasoning for the modification.\nRepeat the calculation and plotting from Task 1 for your modified problem to demonstrate the increased variance in the error bounds. Report the ratio of the maximum to minimum values for different permutations before and after adversarial dataset construction.\n\nTesting SGD Convergence [5 points]\n\nUsing the adversarial dataset from Task 2, identify two specific permutations: \\sigma_{\\text{low}} with a low error bound E(\\sigma_{\\text{low}}) and \\sigma_{\\text{high}} with a high error bound E(\\sigma_{\\text{high}}).\nImplement SGD for the linear least squares problem \\min_x \\frac{1}{2n} \\|Xx - y\\|^2. Use a fixed, small learning rate (e.g., \\alpha = 0.01/L where L is the Lipschitz constant of the full gradient).\nRun SGD for a sufficient number of epochs (e.g., 50-100), applying the batches deterministically according to the order defined by \\sigma_{\\text{low}} in each epoch. Record the squared error \\|X x_k - y\\|^2 at the end of each epoch k.\nRepeat the SGD run using the fixed batch order defined by \\sigma_{\\text{high}}.\nPlot the convergence curves (squared error vs.¬†epoch number) for both \\sigma_{\\text{low}} and \\sigma_{\\text{high}} on the same graph.\nDiscuss your results. Does the observed convergence speed of SGD correlate with the theoretical asymptotic error bound E(\\sigma)? Does the order of batches appear to matter more in your modified problem compared to the random one?"
  },
  {
    "objectID": "program.html",
    "href": "program.html",
    "title": "",
    "section": "",
    "text": "–ó–∞–Ω—è—Ç–∏–µ 1\n    \n        üìÑ –ü—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏—è ‚Ä¢ üìú –õ–æ–Ω–≥—Ä–∏–¥ ‚Ä¢ üë∑‚Äç‚ôÇÔ∏è Seminar\n    \n    \n        üìÑ –ü—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏—è (CU) ‚Ä¢ üë∑‚Äç‚ôÇÔ∏è Seminar (CU)\n    \n    –í—Å–ø–æ–º–∏–Ω–∞–µ–º –ª–∏–Ω–µ–π–Ω—É—é –∞–ª–≥–µ–±—Ä—É. –ù–µ–∫–æ—Ç–æ—Ä—ã–µ –º–∞—Ç—Ä–∏—á–Ω—ã–µ —Ä–∞–∑–ª–æ–∂–µ–Ω–∏—è. –°–∫–æ—Ä–æ—Å—Ç—å —Å—Ö–æ–¥–∏–º–æ—Å—Ç–∏.\n\n    –ó–∞–Ω—è—Ç–∏–µ 2\n    \n        üìÑ –ü—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏—è ‚Ä¢ üìú –õ–æ–Ω–≥—Ä–∏–¥ ‚Ä¢ üë∑‚Äç‚ôÇÔ∏è Seminar\n    \n    \n        üìÑ –ü—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏—è (CU) ‚Ä¢ üë∑‚Äç‚ôÇÔ∏è Seminar (CU)\n    \n    –û–¥–Ω–æ–º–µ—Ä–Ω–∞—è –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è. –ù–µ—Ç–æ—á–Ω–∞—è –æ–¥–Ω–æ–º–µ—Ä–Ω–∞—è –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è. –ì—Ä–∞–¥–∏–µ–Ω—Ç. –ì–µ—Å—Å–∏–∞–Ω. –ú–∞—Ç—Ä–∏—á–Ω–æ-–≤–µ–∫—Ç–æ—Ä–Ω–æ–µ –¥–∏—Ñ—Ñ–µ—Ä–µ–Ω—Ü–∏—Ä–æ–≤–∞–Ω–∏–µ.\n\n    –ó–∞–Ω—è—Ç–∏–µ 3\n    \n        üìÑ –ü—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏—è ‚Ä¢ üìú –õ–æ–Ω–≥—Ä–∏–¥ ‚Ä¢ üë∑‚Äç‚ôÇÔ∏è Seminar\n    \n    \n        üìÑ –ü—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏—è (CU) ‚Ä¢ üë∑‚Äç‚ôÇÔ∏è Seminar (CU)\n    \n    –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ –¥–∏—Ñ—Ñ–µ—Ä–µ–Ω—Ü–∏—Ä–æ–≤–∞–Ω–∏–µ. –í—ã—á–∏—Å–ª–∏—Ç–µ–ª—å–Ω—ã–π –≥—Ä–∞—Ñ.\n\n    –ó–∞–Ω—è—Ç–∏–µ 4\n    \n        üìÑ –ü—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏—è ‚Ä¢ üìú –õ–æ–Ω–≥—Ä–∏–¥ ‚Ä¢ üë∑‚Äç‚ôÇÔ∏è Seminar\n    \n    \n        üìÑ –ü—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏—è (CU) ‚Ä¢ üë∑‚Äç‚ôÇÔ∏è Seminar (CU)\n    \n    –í—ã–ø—É–∫–ª–æ—Å—Ç—å. –í—ã–ø—É–∫–ª—ã–µ –º–Ω–æ–∂–µ—Å—Ç–≤–∞. –í—ã–ø—É–∫–ª—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏. –ù–µ—Ä–∞–≤–µ–Ω—Å—Ç–≤–æ –ô–µ–Ω—Å–µ–Ω–∞. –°–∏–ª—å–Ω–æ –≤—ã–ø—É–∫–ª—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏. –£—Å–ª–æ–≤–∏–µ –ü–æ–ª—è–∫–∞ - –õ–æ—è—Å–∏–µ–≤–∏—á–∞. –ú–∏–Ω–∏–º—É–º—ã –ª–∏–Ω–µ–π–Ω—ã—Ö –Ω–µ–π—Ä–æ–Ω–Ω—ã—Ö —Å–µ—Ç–µ–π.\n\n    –ó–∞–Ω—è—Ç–∏–µ 5\n    \n        üìÑ –ü—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏—è ‚Ä¢ üìú –õ–æ–Ω–≥—Ä–∏–¥ ‚Ä¢ üë∑‚Äç‚ôÇÔ∏è Seminar\n    \n    \n        \n    \n    –£—Å–ª–æ–≤–∏—è –æ–ø—Ç–∏–º–∞–ª—å–Ω–æ—Å—Ç–∏. –§—É–Ω–∫—Ü–∏—è –õ–∞–≥—Ä–∞–Ω–∂–∞. –ó–∞–¥–∞—á–∏ —Å –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è–º–∏-—Ä–∞–≤–µ–Ω—Å—Ç–≤–∞–º–∏. –ó–∞–¥–∞—á–∏ —Å –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è–º–∏-—Ä–∞–≤–µ–Ω—Å—Ç–≤–∞–º–∏. –¢–µ–æ—Ä–µ–º–∞ –ö–∞—Ä—É—à–∞ - –ö—É–Ω–∞ - –¢–∞–∫–∫–µ—Ä–∞.\n\n    –ó–∞–Ω—è—Ç–∏–µ 6\n    \n        üìÑ –ü—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏—è ‚Ä¢ üìú –õ–æ–Ω–≥—Ä–∏–¥ ‚Ä¢ üë∑‚Äç‚ôÇÔ∏è Seminar\n    \n    \n        \n    \n    –ó–∞–¥–∞—á–∞ –ª–∏–Ω–µ–π–Ω–æ–≥–æ –ø—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–∏—è. –°–∏–º–ø–ª–µ–∫—Å –º–µ—Ç–æ–¥.\n\n    –ó–∞–Ω—è—Ç–∏–µ 7\n    \n        üìÑ –ü—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏—è ‚Ä¢ üìú –õ–æ–Ω–≥—Ä–∏–¥ ‚Ä¢ üë∑‚Äç‚ôÇÔ∏è Seminar\n    \n    \n        \n    \n    –ì—Ä–∞–¥–∏–µ–Ω—Ç–Ω—ã–π —Å–ø—É—Å–∫. –¢–µ–æ—Ä–µ–º—ã —Å—Ö–æ–¥–∏–º–æ—Å—Ç–∏ –≤ –≥–ª–∞–¥–∫–æ–º —Å–ª—É—á–∞–µ (–≤—ã–ø—É–∫–ª—ã–µ, —Å–∏–ª—å–Ω–æ –≤—ã–ø—É–∫–ª—ã–µ, PL). –í–µ—Ä—Ö–Ω–∏–µ –∏ –Ω–∏–∂–Ω–∏–µ –æ—Ü–µ–Ω–∫–∏ —Å—Ö–æ–¥–∏–º–æ—Å—Ç–∏.\n\n    –ó–∞–Ω—è—Ç–∏–µ 8\n    \n        üìÑ –ü—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏—è ‚Ä¢ üìú –õ–æ–Ω–≥—Ä–∏–¥ ‚Ä¢ üë∑‚Äç‚ôÇÔ∏è Seminar\n    \n    \n        \n    \n    –£—Å–∫–æ—Ä–µ–Ω–Ω—ã–µ –≥—Ä–∞–¥–∏–µ–Ω—Ç–Ω—ã–µ –º–µ—Ç–æ–¥—ã. –ú–µ—Ç–æ–¥ –ü–æ–ª—è–∫–∞, –ù–µ—Å—Ç–µ—Ä–æ–≤–∞.\n\n    –ó–∞–Ω—è—Ç–∏–µ 9\n    \n        üìÑ –ü—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏—è ‚Ä¢ üìú –õ–æ–Ω–≥—Ä–∏–¥ ‚Ä¢ üë∑‚Äç‚ôÇÔ∏è Seminar\n    \n    \n        \n    \n    –ú–µ—Ç–æ–¥ —Å–æ–ø—Ä—è–∂–µ–Ω–Ω—ã—Ö –≥—Ä–∞–¥–∏–µ–Ω—Ç–æ–≤.\n\n    –ó–∞–Ω—è—Ç–∏–µ 10\n    \n        üìÑ –ü—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏—è ‚Ä¢ üìú –õ–æ–Ω–≥—Ä–∏–¥ ‚Ä¢ üë∑‚Äç‚ôÇÔ∏è Seminar\n    \n    \n        \n    \n    –ú–µ—Ç–æ–¥ –ù—å—é—Ç–æ–Ω–∞. –ö–≤–∞–∑–∏–Ω—å—é—Ç–æ–Ω–æ–≤—Å–∫–∏–µ –º–µ—Ç–æ–¥—ã.\n\n    –ó–∞–Ω—è—Ç–∏–µ 11\n    \n        üìÑ –ü—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏—è ‚Ä¢ üìú –õ–æ–Ω–≥—Ä–∏–¥ ‚Ä¢ üë∑‚Äç‚ôÇÔ∏è Seminar\n    \n    \n        \n    \n    –ì—Ä–∞–¥–∏–µ–Ω—Ç–Ω—ã–µ –º–µ—Ç–æ–¥—ã –≤ —É—Å–ª–æ–≤–Ω—ã—Ö –∑–∞–¥–∞—á–∞—Ö –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏ - –º–µ—Ç–æ–¥ –ø—Ä–æ–µ–∫—Ü–∏–∏ –≥—Ä–∞–¥–∏–µ–Ω—Ç–∞. –ú–µ—Ç–æ–¥ –§—Ä–∞–Ω–∫ - –í—É–ª—å—Ñ–∞. –ò–¥–µ—è –º–µ—Ç–æ–¥–∞ –∑–µ—Ä–∫–∞–ª—å–Ω–æ–≥–æ —Å–ø—É—Å–∫–∞.\n\n    –ó–∞–Ω—è—Ç–∏–µ 12\n    \n        üìÑ –ü—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏—è ‚Ä¢ üìú –õ–æ–Ω–≥—Ä–∏–¥ ‚Ä¢ üë∑‚Äç‚ôÇÔ∏è Seminar\n    \n    \n        \n    \n    –°—É–±–≥—Ä–∞–¥–∏–µ–Ω—Ç. –°—É–±–¥–∏—Ñ—Ñ–µ—Ä–µ–Ω—Ü–∏–∞–ª. –°—É–±–≥—Ä–∞–¥–∏–µ–Ω—Ç–Ω—ã–π —Å–ø—É—Å–∫. –¢–µ–æ—Ä–µ–º—ã —Å—Ö–æ–¥–∏–º–æ—Å—Ç–∏ –≤ –Ω–µ–≥–ª–∞–¥–∫–æ–º —Å–ª—É—á–∞–µ. –û—Å–æ–±–µ–Ω–Ω–æ—Å—Ç–∏ —Ä–∞–±–æ—Ç—ã –≥—Ä–∞–¥–∏–µ–Ω—Ç–Ω–æ–≥–æ –º–µ—Ç–æ–¥–∞ –≤ –ø—Ä–∞–∫—Ç–∏—á–µ—Å–∫–∏—Ö –Ω–µ–≥–ª–∞–¥–∫–∏—Ö –∑–∞–¥–∞—á–∞—Ö. –ü—Ä–æ–∫—Å–∏–º–∞–ª—å–Ω—ã–π –≥—Ä–∞–¥–∏–µ–Ω—Ç–Ω—ã–π –º–µ—Ç–æ–¥.\n\n    –ó–∞–Ω—è—Ç–∏–µ 13\n    \n        üìÑ –ü—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏—è ‚Ä¢ üìú –õ–æ–Ω–≥—Ä–∏–¥ ‚Ä¢ üë∑‚Äç‚ôÇÔ∏è Seminar\n    \n    \n        \n    \n    –°—Ç–æ—Ö–∞—Å—Ç–∏—á–µ—Å–∫–∏–π –≥—Ä–∞–¥–∏–µ–Ω—Ç–Ω—ã–π —Å–ø—É—Å–∫.\n\n    –ó–∞–Ω—è—Ç–∏–µ 14\n    \n        üìÑ –ü—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏—è ‚Ä¢ üìú –õ–æ–Ω–≥—Ä–∏–¥ ‚Ä¢ üë∑‚Äç‚ôÇÔ∏è Seminar\n    \n    \n        \n    \n    –ú–µ—Ç–æ–¥—ã —Ä–µ–¥—É–∫—Ü–∏–∏ –¥–∏—Å–ø–µ—Ä—Å–∏–∏: SAG, SVRG, SAGA. –ê–¥–∞–ø—Ç–∏–≤–Ω—ã–µ —Å—Ç–æ—Ö–∞—Å—Ç–∏—á–µ—Å–∫–∏–µ –≥—Ä–∞–¥–∏–µ–Ω—Ç–Ω—ã–µ –º–µ—Ç–æ–¥—ã. –°–æ–≤—Ä–µ–º–µ–Ω–Ω—ã–µ –º–µ—Ç–æ–¥—ã –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏ –¥–ª—è –æ–±—É—á–µ–Ω–∏—è –Ω–µ–π—Ä–æ–Ω–Ω—ã—Ö —Å–µ—Ç–µ–π\n\n–ù–µ—Ç –ø–æ–¥—Ö–æ–¥—è—â–∏—Ö —ç–ª–µ–º–µ–Ω—Ç–æ–≤"
  },
  {
    "objectID": "short_program.html",
    "href": "short_program.html",
    "title": "–ü—Ä–æ–≥—Ä–∞–º–º–∞ –∫—É—Ä—Å–∞ ‚Äú–û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è –¥–ª—è –≤—Å–µ—Ö‚Äù",
    "section": "",
    "text": "–ü—Ä–æ–≥—Ä–∞–º–º–∞ –∫—É—Ä—Å–∞ ‚Äú–û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è –¥–ª—è –≤—Å–µ—Ö‚Äù\n\n\n\n\n\n\n\n\n‚Ññ\n–¢–µ–º–∞ –õ–µ–∫—Ü–∏–∏\n–¢–µ–º–∞ –ø—Ä–∞–∫—Ç–∏—á–µ—Å–∫–æ–≥–æ –∑–∞–Ω—è—Ç–∏—è\n\n\n\n\n1\n–í—Å–ø–æ–º–∏–Ω–∞–µ–º –ª–∏–Ω–µ–π–Ω—É—é –∞–ª–≥–µ–±—Ä—É. –°–∫–æ—Ä–æ—Å—Ç—å —Å—Ö–æ–¥–∏–º–æ—Å—Ç–∏\n–ú–∞—Ç—Ä–∏—á–Ω—ã–µ –≤—ã—á–∏—Å–ª–µ–Ω–∏—è, –Ω–æ—Ä–º—ã, LoRA, –∞–Ω–∞–ª–∏–∑ —Å—Ö–æ–¥–∏–º–æ—Å—Ç–∏\n\n\n2\n–ú–∞—Ç—Ä–∏—á–Ω–æ–µ –¥–∏—Ñ—Ñ–µ—Ä–µ–Ω—Ü–∏—Ä–æ–≤–∞–Ω–∏–µ –∏ –æ–¥–Ω–æ–º–µ—Ä–Ω–∞—è –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è\n–ì—Ä–∞–¥–∏–µ–Ω—Ç—ã –º–∞—Ç—Ä–∏—á–Ω—ã—Ö —Ñ—É–Ω–∫—Ü–∏–π, line search –º–µ—Ç–æ–¥—ã, Brent method\n\n\n3\n–ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ –¥–∏—Ñ—Ñ–µ—Ä–µ–Ω—Ü–∏—Ä–æ–≤–∞–Ω–∏–µ\nForward/reverse mode AD, gradient checkpointing, JAX –ø—Ä–∞–∫—Ç–∏–∫—É–º\n\n\n4\n–í—ã–ø—É–∫–ª–æ—Å—Ç—å –∏ —Å–∏–ª—å–Ω–∞—è –≤—ã–ø—É–∫–ª–æ—Å—Ç—å\n–î–æ–∫–∞–∑–∞—Ç–µ–ª—å—Å—Ç–≤–∞ –≤—ã–ø—É–∫–ª–æ—Å—Ç–∏, PL-—É—Å–ª–æ–≤–∏–µ, –ª–æ–≥–∏—Å—Ç–∏—á–µ—Å–∫–∞—è —Ä–µ–≥—Ä–µ—Å—Å–∏—è, SVM\n\n\n5\n–£—Å–ª–æ–≤–∏—è –æ–ø—Ç–∏–º–∞–ª—å–Ω–æ—Å—Ç–∏ –∏ KKT\n–ú–Ω–æ–∂–∏—Ç–µ–ª–∏ –õ–∞–≥—Ä–∞–Ω–∂–∞, KKT —É—Å–ª–æ–≤–∏—è, adversarial attacks\n\n\n6\n–õ–∏–Ω–µ–π–Ω–æ–µ –ø—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–∏–µ –∏ —Å–∏–º–ø–ª–µ–∫—Å-–∞–ª–≥–æ—Ä–∏—Ç–º\n–ü–ª–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ –ø—Ä–æ–∏–∑–≤–æ–¥—Å—Ç–≤–∞, max-flow min-cut, –ø—Ä–∏–º–µ–Ω–µ–Ω–∏—è –õ–ü\n\n\n7\n–ì—Ä–∞–¥–∏–µ–Ω—Ç–Ω—ã–π —Å–ø—É—Å–∫ –∏ –∞–Ω–∞–ª–∏–∑ —Å—Ö–æ–¥–∏–º–æ—Å—Ç–∏\n–¢–µ–æ—Ä–µ—Ç–∏—á–µ—Å–∫–∏–π –∞–Ω–∞–ª–∏–∑, –≤—ã–±–æ—Ä —Ä–∞–∑–º–µ—Ä–∞ —à–∞–≥–∞, PL-—É—Å–ª–æ–≤–∏–µ\n\n\n8\n–£—Å–∫–æ—Ä–µ–Ω–∏–µ –≥—Ä–∞–¥–∏–µ–Ω—Ç–Ω–æ–≥–æ —Å–ø—É—Å–∫–∞\nHeavy Ball, Nesterov acceleration, hobbit village challenge\n\n\n9\n–ú–µ—Ç–æ–¥ —Å–æ–ø—Ä—è–∂–µ–Ω–Ω—ã—Ö –≥—Ä–∞–¥–∏–µ–Ω—Ç–æ–≤\nCG –¥–ª—è –∫–≤–∞–¥—Ä–∞—Ç–∏—á–Ω—ã—Ö –∑–∞–¥–∞—á, –Ω–µ–ª–∏–Ω–µ–π–Ω—ã–π CG, –ø–∞—Ç–æ–ª–æ–≥–∏—á–µ—Å–∫–∏–µ –ø—Ä–∏–º–µ—Ä—ã\n\n\n10\n–ú–µ—Ç–æ–¥ –ù—å—é—Ç–æ–Ω–∞ –∏ –∫–≤–∞–∑–∏-–ù—å—é—Ç–æ–Ω–æ–≤—Å–∫–∏–µ –º–µ—Ç–æ–¥—ã\nNewton method, BFGS, L-BFGS, cubic-regularized Newton\n\n\n11\n–ü—Ä–æ–µ–∫—Ü–∏–æ–Ω–Ω—ã–µ –º–µ—Ç–æ–¥—ã –∏ Frank-Wolfe\n–ü—Ä–æ–µ–∫—Ü–∏—è –Ω–∞ —Å–∏–º–ø–ª–µ–∫—Å, PGD, Frank-Wolfe algorithm\n\n\n12\n–°—É–±–≥—Ä–∞–¥–∏–µ–Ω—Ç—ã –∏ –ø—Ä–æ–∫—Å–∏–º–∞–ª—å–Ω—ã–µ –º–µ—Ç–æ–¥—ã\n–°—É–±–¥–∏—Ñ—Ñ–µ—Ä–µ–Ω—Ü–∏–∞–ª—ã, ISTA/FISTA, image denoising, L1-—Ä–µ–≥—É–ª—è—Ä–∏–∑–∞—Ü–∏—è\n\n\n13\n–°—Ç–æ—Ö–∞—Å—Ç–∏—á–µ—Å–∫–∏–π –≥—Ä–∞–¥–∏–µ–Ω—Ç–Ω—ã–π —Å–ø—É—Å–∫\nSGD vs GD, –∞–¥–∞–ø—Ç–∏–≤–Ω—ã–µ –º–µ—Ç–æ–¥—ã (Adam, AdaGrad, RMSProp, AdamW)\n\n\n14\n–ú–µ—Ç–æ–¥—ã —É–º–µ–Ω—å—à–µ–Ω–∏—è –¥–∏—Å–ø–µ—Ä—Å–∏–∏\nSVRG, SAG/SAGA, —ç–∫—Å–ø–µ—Ä–∏–º–µ–Ω—Ç—ã —Å –Ω–µ–π—Ä–æ—Å–µ—Ç—è–º–∏\n\n\n15\n–°–æ–≤—Ä–µ–º–µ–Ω–Ω—ã–µ –º–µ—Ç–æ–¥—ã –∏ –ø—Ä–∞–∫—Ç–∏–∫–∏ –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏\nSAM, mode connectivity, grokking, Muon optimizer, distributed training"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "–û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è –¥–ª—è –≤—Å–µ—Ö",
    "section": "",
    "text": "–û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è –¥–ª—è –≤—Å–µ—Ö\n\n–ö—É—Ä—Å –¥–ª—è —Å—Ç—É–¥–µ–Ω—Ç–æ–≤ –¶–µ–Ω—Ç—Ä–∞–ª—å–Ω–æ–≥–æ –£–Ω–∏–≤–µ—Ä—Å–∏—Ç–µ—Ç–∞. 1 –ª–µ–∫—Ü–∏—è + 1 —Å–µ–º–∏–Ω–∞—Ä –≤ –Ω–µ–¥–µ–ª—é.\n–ö—É—Ä—Å –æ—Ö–≤–∞—Ç—ã–≤–∞–µ—Ç —Ç–µ–º—ã –≤—ã–ø—É–∫–ª–æ–π, –Ω–µ–≤—ã–ø—É–∫–ª–æ–π, –Ω–µ–ø—Ä–µ—Ä—ã–≤–Ω–æ–π –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏, –æ—Å–æ–±–µ–Ω–Ω–æ –º–æ—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –∑–∞–¥–∞—á–∞–º–∏ –∏ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è–º–∏ –≤ –º–∞—à–∏–Ω–Ω–æ–º –æ–±—É—á–µ–Ω–∏–∏. –†–∞—Å—Å–º–∞—Ç—Ä–∏–≤–∞—é—Ç—Å—è —Ä–∞–∑–ª–∏—á–Ω—ã–µ —Ç–µ–º—ã, –æ—Ç —Ñ—É–Ω–¥–∞–º–µ–Ω—Ç–∞–ª—å–Ω—ã—Ö –º–∞—Ç–µ—Ä–∏–∞–ª–æ–≤ –¥–æ –ø–æ—Å–ª–µ–¥–Ω–∏—Ö –∏—Å—Å–ª–µ–¥–æ–≤–∞–Ω–∏–π.\nüìú –ü—Ä–∞–≤–∏–ª–∞ –∫—É—Ä—Å–∞\n\nYour browser does not support the video tag.\n\n\nTeam\n\n\n    \n        \n            \n                \n                  \n                    \n                  \n                  \n                    \n                      –î–∞–Ω–∏–∏–ª –ú–µ—Ä–∫—É–ª–æ–≤\n                    \n                    –õ–µ–∫—Ç–æ—Ä –¥–ª—è –±–∞–∫–∞–ª–∞–≤—Ä–æ–≤\n                  \n                \n              \n        \n            \n                \n                  \n                    \n                  \n                  \n                    \n                      –î–µ–Ω–∏—Å –†—É–±—Ü–æ–≤\n                    \n                    –°–µ–º–∏–Ω–∞—Ä–∏—Å—Ç –¥–ª—è –±–∞–∫–∞–ª–∞–≤—Ä–æ–≤\n                  \n                \n              \n        \n            \n                \n                  \n                    \n                  \n                  \n                    \n                      –ü–µ—Ç—Ä –û—Å—Ç—Ä–æ—É—Ö–æ–≤\n                    \n                    –õ–µ–∫—Ç–æ—Ä –∏ —Å–µ–º–∏–Ω–∞—Ä–∏—Å—Ç –¥–ª—è –º–∞–≥–∏—Å—Ç—Ä–æ–≤\n                  \n                \n              \n        \n            \n                \n                  \n                    \n                  \n                  \n                    \n                      –ê–Ω–Ω–∞ –ü–µ—Ç—Ä–æ–≤–∞\n                    \n                    –°—Ç–∞—Ä—à–∏–π –∞—Å—Å–∏—Å—Ç–µ–Ω—Ç\n                  \n                \n              \n        \n            \n                \n                  \n                    \n                  \n                  \n                    \n                      –ê–ª–µ–∫—Å–µ–π –†–µ–±—Ä–∏–∫–æ–≤\n                    \n                    –°—Ç–∞—Ä—à–∏–π –∞—Å—Å–∏—Å—Ç–µ–Ω—Ç\n                  \n                \n              \n        \n            \n                \n                  \n                    \n                  \n                  \n                    \n                      –§–∞–Ω–∏—Å –•–∞—Ñ–∏–∑–æ–≤\n                    \n                    –ê—Å—Å–∏—Å—Ç–µ–Ω—Ç\n                  \n                \n              \n        \n            \n                \n                  \n                    \n                  \n                  \n                    \n                      –ê–Ω–∞—Å—Ç–∞—Å–∏—è –ì–µ—Ä–º–∞–Ω\n                    \n                    –ê—Å—Å–∏—Å—Ç–µ–Ω—Ç\n                  \n                \n              \n        \n            \n                \n                  \n                    \n                  \n                  \n                    \n                      –ú–∞–∫—Å–∏–º –®—É–∫–ª–∏–Ω\n                    \n                    –ê—Å—Å–∏—Å—Ç–µ–Ω—Ç\n                  \n                \n              \n        \n            \n                \n                  \n                    \n                  \n                  \n                    \n                      –ê–ª–µ–∫—Å–µ–π –ö—Ä–∞–≤–∞—Ü–∫–∏–π\n                    \n                    –ê—Å—Å–∏—Å—Ç–µ–Ω—Ç\n                  \n                \n              \n        \n            \n                \n                  \n                    \n                  \n                  \n                    \n                      –î–∞–Ω–∏–∏–ª –ö–∞–∑–∞—á–∫–æ–≤\n                    \n                    –ê—Å—Å–∏—Å—Ç–µ–Ω—Ç\n                  \n                \n              \n        \n            \n                \n                  \n                    \n                  \n                  \n                    \n                      –í—è—á–µ—Å–ª–∞–≤ –õ—è–º–∫–∏–Ω\n                    \n                    –ê—Å—Å–∏—Å—Ç–µ–Ω—Ç\n                  \n                \n              \n        \n            \n                \n                  \n                    \n                  \n                  \n                    \n                      –ê–º–∏—Ä –ó–∞–π–Ω—É–ª–ª–∏–Ω\n                    \n                    –ê—Å—Å–∏—Å—Ç–µ–Ω—Ç\n                  \n                \n              \n        \n            \n                \n                  \n                    \n                  \n                  \n                    \n                      –°–æ—Ñ–∏—è –î–æ—Ä–æ–≥–æ–≤–∞\n                    \n                    –ê—Å—Å–∏—Å—Ç–µ–Ω—Ç\n                  \n                \n              \n        \n    \n\n–ù–µ—Ç –ø–æ–¥—Ö–æ–¥—è—â–∏—Ö —ç–ª–µ–º–µ–Ω—Ç–æ–≤"
  }
]